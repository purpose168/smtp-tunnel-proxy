#!/usr/bin/env python3
"""
SMTP 隧道 - 添加用户脚本

创建新用户并生成客户端包（ZIP 文件）。

版本: 1.3.0
"""

import argparse  # 命令行参数解析库
import os        # 操作系统接口库
import sys       # 系统相关功能库
import secrets   # 安全随机数生成库
import zipfile   # ZIP 文件操作库
import tempfile  # 临时文件/目录创建库
import shutil    # 高级文件操作库
import pathlib   # 路径处理库

# 将当前目录添加到导入路径，以便导入本地模块
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from common import load_users, save_users, load_config, UserConfig  # 导入通用函数和用户配置类


def find_project_root() -> str:
    """查找项目根目录，尝试多个可能的位置。"""
    possible_roots = [
        os.path.dirname(os.path.abspath(__file__)),  # 当前脚本所在目录
        '/opt/smtp-tunnel',                          # 标准安装目录
        os.path.join(os.path.dirname(os.path.abspath(__file__)), '..'),  # 上级目录
    ]
    
    # 检查常见的项目文件（包括拆分后的模块）
    project_files = [
        'server.py', 'client.py', 'common.py', 'requirements.txt',
        'protocol.py', 'tunnel/crypto.py', 'traffic.py', 'smtp_message.py', 'config.py',
        'socks5_server.py',
        'server_connection.py', 'tunnel/server.py',
        'tunnel/__init__.py', 'tunnel/base.py', 'tunnel/client.py', 'tunnel/session.py'
    ]
    
    for root in possible_roots:
        # 检查是否包含所有必需的文件
        found_files = 0
        for project_file in project_files:
            if os.path.exists(os.path.join(root, project_file)):
                found_files += 1
        
        # 如果找到大部分文件，认为这是项目根目录
        if found_files >= 10:
            return root
    
    # 如果都找不到，返回当前脚本目录
    return os.path.dirname(os.path.abspath(__file__))


def find_required_files(base_dir: str) -> dict:
    """查找必需的文件，返回找到的文件路径字典。"""
    required_files = {
        # 主入口文件
        'client.py': 'client.py',
        'common.py': 'common.py',
        'requirements.txt': 'requirements.txt',
        'ca.crt': 'ca.crt',
        # 从 common.py 拆分出的模块
        'protocol.py': 'protocol.py',
        'tunnel/crypto.py': 'tunnel/crypto.py',
        'traffic.py': 'traffic.py',
        'smtp_message.py': 'smtp_message.py',
        'config.py': 'config.py',
        # 从 client.py 拆分出的模块
        'socks5_server.py': 'socks5_server.py',
        # tunnel 模块
        'tunnel/__init__.py': 'tunnel/__init__.py',
        'tunnel/base.py': 'tunnel/base.py',
        'tunnel/client.py': 'tunnel/client.py',
        'tunnel/session.py': 'tunnel/session.py',
        'tunnel/server.py': 'tunnel/server.py',
    }
    
    found_files = {}
    
    for key, filename in required_files.items():
        file_path = os.path.join(base_dir, filename)
        if os.path.exists(file_path):
            found_files[key] = file_path
        else:
            # 尝试在上级目录中查找
            parent_path = os.path.join(base_dir, '..', filename)
            if os.path.exists(parent_path):
                found_files[key] = parent_path
            else:
                found_files[key] = None
    
    return found_files


def generate_secret() -> str:
    """生成安全的随机密钥。"""
    return secrets.token_urlsafe(32)  # 生成32字节的URL安全随机密钥


def create_client_config(server_host: str, server_port: int, username: str, secret: str) -> str:
    """生成客户端 config.yaml 配置内容。"""
    return f"""# SMTP 隧道客户端配置
# 为用户生成: {username}

client:
  # 服务器连接配置
  server_host: "{server_host}"      # 服务器主机名
  server_port: {server_port}        # 服务器端口

  # 身份验证配置
  username: "{username}"            # 用户名
  secret: "{secret}"                # 身份验证密钥

  # 本地 SOCKS5 代理配置
  socks_port: 1080                  # SOCKS5 代理端口
  socks_host: "127.0.0.1"          # SOCKS5 代理监听地址

  # 用于服务器验证的 CA 证书
  ca_cert: "ca.crt"                 # CA 证书文件路径
"""


def create_client_package(
    username: str,                  # 用户名
    secret: str,                    # 用户密钥
    server_host: str,               # 服务器主机名
    server_port: int,               # 服务器端口
    base_dir: str,                  # 基础目录路径
    output_dir: str                 # 输出目录路径
) -> str:
    """
    创建包含客户端所需所有文件的 ZIP 包。

    返回:
        创建的 ZIP 文件路径
    """
    # 查找必需的文件
    files = find_required_files(base_dir)
    
    # 客户端文件列表（包括拆分后的所有模块）
    client_files = [
        # 主入口文件
        'client.py', 'common.py',
        # 从 common.py 拆分出的模块
        'protocol.py', 'tunnel/crypto.py', 'traffic.py', 'smtp_message.py', 'config.py',
        # 从 client.py 拆分出的模块
        'socks5_server.py',
        # tunnel 模块
        'tunnel/__init__.py', 'tunnel/base.py', 'tunnel/client.py',
        'requirements.txt'
    ]
    
    # 检查 ca.crt 证书文件是否存在
    has_ca_cert = files['ca.crt'] is not None

    # 创建临时目录用于打包
    with tempfile.TemporaryDirectory() as tmpdir:
        pkg_dir = os.path.join(tmpdir, username)  # 用户包目录
        os.makedirs(pkg_dir)                       # 创建目录

        # 复制客户端文件
        for filename in client_files:
            if files[filename] and os.path.exists(files[filename]):
                shutil.copy(files[filename], pkg_dir)            # 复制文件到包目录
            else:
                print(f"警告: {filename} 未找到，跳过")

        # 如果存在 CA 证书则复制
        if has_ca_cert:
            shutil.copy(files['ca.crt'], pkg_dir)       # 复制 CA 证书
        else:
            print("警告: ca.crt 未找到 - 客户端将无法验证服务器")

        # 生成客户端配置文件
        config_content = create_client_config(server_host, server_port, username, secret)
        config_path = os.path.join(pkg_dir, 'config.yaml')
        with open(config_path, 'w') as f:
            f.write(config_content)                   # 写入配置内容

        # 为用户创建 README 说明文件
        readme_content = f"""# SMTP 隧道客户端 - {username}

## 快速开始

1. 安装依赖:
   pip install -r requirements.txt

2. 运行客户端:
   python client.py

3. 配置浏览器/应用程序使用 SOCKS5 代理:
   主机: 127.0.0.1
   端口: 1080

## 文件说明

### 主程序文件
- client.py      - 隧道客户端主程序
- common.py      - 共享库文件（兼容层）

### 核心模块
- protocol.py    - 二进制协议定义
- crypto.py      - 加密和认证功能
- traffic.py     - 流量伪装（DPI 规避）
- smtp_message.py - MIME 邮件生成
- config.py      - 配置管理

### 客户端模块
- socks5_server.py   - SOCKS5 服务器
- tunnel/           - 隧道模块（包含客户端和服务器共享功能）

### 配置文件
- config.yaml    - 您的配置文件（已预配置）
- ca.crt         - 用于验证的服务器证书
- requirements.txt - Python 依赖列表

## 测试连接

curl -x socks5h://127.0.0.1:1080 https://ifconfig.me

## 简易启动

Windows: 双击 start.bat
Linux/Mac: 运行 ./start.sh
"""
        readme_path = os.path.join(pkg_dir, 'README.txt')
        with open(readme_path, 'w') as f:
            f.write(readme_content)                   # 写入 README 内容

        # 创建 Windows 启动脚本（start.bat）
        bat_content = f'''@echo off
chcp 65001 >nul 2>&1
title SMTP 隧道 - {username}

echo.
echo  ╔═══════════════════════════════════════════════════════════╗
echo  ║                                                           ║
echo  ║   ███████╗███╗   ███╗████████╗██████╗                     ║
echo  ║   ██╔════╝████╗ ████║╚══██╔══╝██╔══██╗                    ║
echo  ║   ███████╗██╔████╔██║   ██║   ██████╔╝                    ║
echo  ║   ╚════██║██║╚██╔╝██║   ██║   ██╔═══╝                     ║
echo  ║   ███████║██║ ╚═╝ ██║   ██║   ██║                         ║
echo  ║   ╚══════╝╚═╝     ╚═╝   ╚═╝   ╚═╝                         ║
echo  ║                                                           ║
echo  ║   SMTP 隧道代理客户端                                      ║
echo  ║   用户: {username:50}║
echo  ║                                                           ║
echo  ╚═══════════════════════════════════════════════════════════╝
echo.

:: 检查 Python 是否安装
where python >nul 2>&1
if %errorlevel% neq 0 (
    where python3 >nul 2>&1
    if %errorlevel% neq 0 (
        echo [错误] 未找到 Python！
        echo.
        echo 请从以下地址安装 Python 3.8+:
        echo   https://www.python.org/downloads/
        echo.
        echo 安装时请确保勾选"Add Python to PATH"选项。
        echo.
        pause
        exit /b 1
    )
    set PYTHON=python3
) else (
    set PYTHON=python
)

echo [信息] 找到 Python: %PYTHON%

:: 检查/安装依赖
echo [信息] 检查依赖项...
%PYTHON% -c "import yaml" >nul 2>&1
if %errorlevel% neq 0 (
    echo [信息] 正在安装依赖项...
    %PYTHON% -m pip install -r requirements.txt --quiet
    if %errorlevel% neq 0 (
        echo [错误] 依赖项安装失败
        pause
        exit /b 1
    )
    echo [信息] 依赖项安装完成
)

echo.
echo [信息] 正在启动 SMTP 隧道...
echo [信息] SOCKS5 代理将在 127.0.0.1:1080 上可用
echo.
echo 按 Ctrl+C 停止
echo ─────────────────────────────────────────────────────────────
echo.

%PYTHON% client.py

echo.
echo 连接已关闭。
echo 按任意键退出...
pause >nul
'''
        bat_path = os.path.join(pkg_dir, 'start.bat')
        with open(bat_path, 'w', newline='\r\n') as f:
            f.write(bat_content)                       # 写入 Windows 批处理脚本

        # 创建 Linux/Mac 启动脚本（start.sh）
        sh_content = f'''#!/bin/bash
#
# SMTP 隧道客户端启动器
# 用户: {username}
#

# 颜色定义
RED='\\033[0;31m'      # 红色
GREEN='\\033[0;32m'    # 绿色
YELLOW='\\033[1;33m'   # 黄色
BLUE='\\033[0;34m'     # 蓝色
CYAN='\\033[0;36m'     # 青色
NC='\\033[0m'          # 无颜色

clear
echo ""
echo -e "${{CYAN}}"
echo "  ╔═══════════════════════════════════════════════════════════╗"
echo "  ║                                                           ║"
echo "  ║   ███████╗███╗   ███╗████████╗██████╗                     ║"
echo "  ║   ██╔════╝████╗ ████║╚══██╔══╝██╔══██╗                    ║"
echo "  ║   ███████╗██╔████╔██║   ██║   ██████╔╝                    ║"
echo "  ║   ╚════██║██║╚██╔╝██║   ██║   ██╔═══╝                     ║"
echo "  ║   ███████║██║ ╚═╝ ██║   ██║   ██║                         ║"
echo "  ║   ╚══════╝╚═╝     ╚═╝   ╚═╝   ╚═╝                         ║"
echo "  ║                                                           ║"
echo "  ║   SMTP 隧道代理客户端                                      ║"
echo "  ║   用户: {username:50}║"
echo "  ║                                                           ║"
echo "  ╚═══════════════════════════════════════════════════════════╝"
echo -e "${{NC}}"
echo ""

# 查找 Python
if command -v python3 &> /dev/null; then
    PYTHON=python3
elif command -v python &> /dev/null; then
    PYTHON=python
else
    echo -e "${{RED}}[错误]${{NC}} 未找到 Python！"
    echo ""
    echo "请安装 Python 3.8+:"
    echo "  Ubuntu/Debian: sudo apt install python3 python3-pip"
    echo "  macOS: brew install python3"
    echo "  或从以下地址下载: https://www.python.org/downloads/"
    echo ""
    exit 1
fi

echo -e "${{GREEN}}[信息]${{NC}} 找到 Python: $PYTHON"

# 检查/安装依赖
echo -e "${{GREEN}}[信息]${{NC}} 检查依赖项..."
if ! $PYTHON -c "import yaml" &> /dev/null; then
    echo -e "${{YELLOW}}[信息]${{NC}} 正在安装依赖项..."
    $PYTHON -m pip install -r requirements.txt --quiet
    if [ $? -ne 0 ]; then
        echo -e "${{RED}}[错误]${{NC}} 依赖项安装失败"
        echo "请尝试运行: $PYTHON -m pip install -r requirements.txt"
        exit 1
    fi
    echo -e "${{GREEN}}[信息]${{NC}} 依赖项安装完成"
fi

echo ""
echo -e "${{GREEN}}[信息]${{NC}} 正在启动 SMTP 隧道..."
echo -e "${{GREEN}}[信息]${{NC}} SOCKS5 代理将在 127.0.0.1:1080 上可用"
echo ""
echo -e "按 ${{YELLOW}}Ctrl+C${{NC}} 停止"
echo "─────────────────────────────────────────────────────────────"
echo ""

$PYTHON client.py

echo ""
echo -e "${{YELLOW}}连接已关闭。${{NC}}"
'''
        sh_path = os.path.join(pkg_dir, 'start.sh')
        with open(sh_path, 'w') as f:
            f.write(sh_content)                         # 写入 Shell 脚本
        os.chmod(sh_path, 0o755)                      # 设置可执行权限

        # 创建 ZIP 文件
        zip_filename = f"{username}.zip"
        zip_path = os.path.abspath(os.path.join(output_dir, zip_filename))

        with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
            for root, dirs, files in os.walk(pkg_dir):
                for file in files:
                    file_path = os.path.join(root, file)       # 文件完整路径
                    arcname = os.path.relpath(file_path, tmpdir)  # ZIP 内的相对路径
                    zipf.write(file_path, arcname)             # 添加到 ZIP

        return zip_path


def main():
    parser = argparse.ArgumentParser(
        description='向 SMTP 隧道添加新用户',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
示例:
  %(prog)s alice                    # 添加用户 'alice' 并自动生成密钥
  %(prog)s bob --secret mysecret    # 添加用户 'bob' 并指定密钥
  %(prog)s carol --whitelist 1.2.3.4 --whitelist 10.0.0.0/8
  %(prog)s dave --no-logging        # 添加用户但不记录日志
"""
    )
    parser.add_argument('username', help='要添加的用户名')
    parser.add_argument('--secret', '-s', default=None, help='密钥（未提供则自动生成）')
    parser.add_argument('--whitelist', '-w', action='append', default=[], help='IP 白名单（可指定多个）')
    parser.add_argument('--no-logging', action='store_true', help='为此用户禁用日志记录')
    parser.add_argument('--users-file', '-u', default='/etc/smtp-tunnel/users.yaml', help='用户文件（默认: /etc/smtp-tunnel/users.yaml）')
    parser.add_argument('--config', '-c', default='/etc/smtp-tunnel/config.yaml', help='服务器配置文件（默认: /etc/smtp-tunnel/config.yaml）')
    parser.add_argument('--output-dir', '-o', default='.', help='ZIP 文件输出目录（默认: 当前目录）')
    parser.add_argument('--no-package', action='store_true', help='不生成客户端 ZIP 包')

    args = parser.parse_args()

    # 获取基础目录，查找项目文件
    base_dir = find_project_root()

    # 加载现有用户
    users_file = args.users_file
    if not os.path.isabs(users_file):
        users_file = os.path.join(base_dir, users_file)  # 转换为绝对路径

    users = load_users(users_file)  # 加载用户数据

    # 检查用户是否已存在
    if args.username in users:
        print(f"错误: 用户 '{args.username}' 已存在")
        return 1

    # 如果未提供密钥则生成
    secret = args.secret or generate_secret()

    # 创建用户配置
    user = UserConfig(
        username=args.username,
        secret=secret,
        whitelist=args.whitelist if args.whitelist else [],
        logging=not args.no_logging
    )

    # 添加用户
    users[args.username] = user

    # 保存用户文件
    save_users(users_file, users)
    print(f"用户 '{args.username}' 已添加到 {users_file}")

    # 生成客户端包
    if not args.no_package:
        # 加载服务器配置以获取主机名和端口
        config_file = args.config
        if not os.path.isabs(config_file):
            config_file = os.path.join(base_dir, config_file)  # 转换为绝对路径

        try:
            config_data = load_config(config_file)            # 加载配置
            server_conf = config_data.get('server', {})
            server_host = server_conf.get('hostname', 'localhost')
            server_port = server_conf.get('port', 587)
        except FileNotFoundError:
            print(f"警告: 配置文件 {config_file} 未找到，使用默认值")
            server_host = 'localhost'
            server_port = 587

        output_dir = args.output_dir
        if not os.path.isabs(output_dir):
            output_dir = os.path.join(os.getcwd(), output_dir)  # 转换为绝对路径

        zip_path = create_client_package(
            username=args.username,
            secret=secret,
            server_host=server_host,
            server_port=server_port,
            base_dir=base_dir,
            output_dir=output_dir
        )

        print(f"客户端包已创建: {zip_path}")
        print()
        print("将此 ZIP 文件发送给用户。他们只需要:")
        print("  1. 解压 ZIP 文件")
        print("  2. pip install -r requirements.txt")
        print("  3. python client.py")

    return 0


if __name__ == '__main__':
    sys.exit(main())
