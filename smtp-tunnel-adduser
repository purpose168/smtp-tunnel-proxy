#!/usr/bin/env python3
"""
SMTP 隧道 - 添加用户脚本

创建新用户并生成客户端包（ZIP 文件）。

版本: 1.3.0
"""

import argparse  # 命令行参数解析库
import os        # 操作系统接口库
import sys       # 系统相关功能库
import secrets   # 安全随机数生成库
import zipfile   # ZIP 文件操作库
import tempfile  # 临时文件/目录创建库
import shutil    # 高级文件操作库
import logging   # 日志记录库
from datetime import datetime, timedelta, timezone  # 用于日期时间处理

# 加密库导入
from cryptography import x509                                   # 用于 X.509 证书操作
from cryptography.x509.oid import NameOID, ExtendedKeyUsageOID  # 用于证书对象标识符
from cryptography.hazmat.primitives import hashes               # 用于哈希算法
from cryptography.hazmat.primitives.asymmetric import rsa       # 用于 RSA 密钥生成
from cryptography.hazmat.primitives import serialization        # 用于密钥和证书序列化
from cryptography.hazmat.backends import default_backend        # 用于加密后端

# 将当前目录添加到导入路径，以便导入本地模块
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
from config import load_users, save_users, load_config, UserConfig  # 导入通用函数和用户配置类

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger('smtp-tunnel-adduser')


def find_project_root() -> str:
    """查找项目根目录，使用脚本执行时的当前路径。"""
    # 直接返回脚本所在目录
    return os.path.dirname(os.path.abspath(__file__))


def find_required_files(base_dir: str) -> dict:
    """查找必需的文件，返回找到的文件路径字典。"""
    required_files = {
        'ca.crt': 'ca.crt',
    }
    
    found_files = {}
    
    for key, filename in required_files.items():
        file_path = os.path.join(base_dir, filename)
        if os.path.exists(file_path):
            found_files[key] = file_path
        else:
            # 尝试在上级目录中查找
            parent_path = os.path.join(base_dir, '..', filename)
            if os.path.exists(parent_path):
                found_files[key] = parent_path
            else:
                found_files[key] = None
    
    return found_files


def generate_secret() -> str:
    """生成安全的随机密钥。"""
    return secrets.token_urlsafe(32)  # 生成32字节的URL安全随机密钥


def create_client_config(server_host: str, server_port: int, username: str, secret: str) -> str:
    """生成客户端 config.yaml 配置内容。"""
    return f"""# SMTP 隧道客户端配置
# 为用户生成: {username}

client:
  # 服务器连接配置
  server_host: "{server_host}"      # 服务器主机名
  server_port: {server_port}        # 服务器端口

  # 身份验证配置
  username: "{username}"            # 用户名
  secret: "{secret}"                # 身份验证密钥

  # 本地 SOCKS5 代理配置
  socks_port: 1080                  # SOCKS5 代理端口
  socks_host: "127.0.0.1"          # SOCKS5 代理监听地址

  # 用于服务器验证的客户端证书
  client_cert: "{username}-client.crt"        # 客户端证书文件路径
  client_key: "{username}-client.key"         # 客户端私钥文件路径
"""


def generate_user_certificate(
    username: str,
    output_dir: str,
    key_size: int = 2048,
    days_valid: int = 1095
) -> tuple:
    """
    为用户生成客户端证书
    
    生成用户专属的客户端证书，用于 SMTP 隧道的 TLS 加密通信。
    客户端证书用于客户端身份验证，包含客户端的公钥和私钥。
    
    Args:
        username: 用户名
        output_dir: 输出目录
        key_size: RSA 密钥大小（位），默认 2048
        days_valid: 证书有效期（天），默认 1095（3 年）
    
    Returns:
        tuple: (client_cert_path, client_key_path)
              客户端证书路径、客户端私钥路径
    
    Raises:
        Exception: 证书生成失败
    """
    logger.info(f"开始为用户 '{username}' 生成客户端证书")
    
    try:
        # ========== 生成客户端私钥 ==========
        logger.debug(f"为用户 '{username}' 生成客户端私钥")
        client_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=key_size,
            backend=default_backend(),
        )
        
        # 客户端证书主题
        client_subject = x509.Name([
            x509.NameAttribute(NameOID.COUNTRY_NAME, "CN"),
            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, "Beijing"),
            x509.NameAttribute(NameOID.LOCALITY_NAME, "Beijing"),
            x509.NameAttribute(NameOID.ORGANIZATION_NAME, "SMTP Tunnel"),
            x509.NameAttribute(NameOID.COMMON_NAME, username),
        ])
        
        # 主题备用名称（SAN）
        san = x509.SubjectAlternativeName([
            x509.DNSName(username),
            x509.DNSName(f"client.{username}"),
            x509.DNSName("localhost"),
        ])
        
        # 生成客户端证书（自签名）
        # 注意：实际使用时，客户端应该使用服务器提供的 CA 证书
        # 这里生成自签名证书用于测试目的
        client_cert = (
            x509.CertificateBuilder()
            .subject_name(client_subject)
            .issuer_name(client_subject)
            .public_key(client_key.public_key())
            .serial_number(x509.random_serial_number())
            .not_valid_before(datetime.now(timezone.utc))
            .not_valid_after(datetime.now(timezone.utc) + timedelta(days=days_valid))
            .add_extension(san, critical=False)
            .add_extension(
                x509.BasicConstraints(ca=False, path_length=None),
                critical=True,
            )
            .add_extension(
                x509.KeyUsage(
                    digital_signature=True,
                    key_encipherment=True,
                    content_commitment=False,
                    data_encipherment=False,
                    key_agreement=False,
                    key_cert_sign=False,
                    crl_sign=False,
                    encipher_only=False,
                    decipher_only=False,
                ),
                critical=True,
            )
            .add_extension(
                x509.ExtendedKeyUsage([
                    ExtendedKeyUsageOID.SERVER_AUTH,
                    ExtendedKeyUsageOID.CLIENT_AUTH,
                ]),
                critical=False,
            )
            .add_extension(
                x509.SubjectKeyIdentifier.from_public_key(client_key.public_key()),
                critical=False,
            )
            .sign(client_key, hashes.SHA256(), default_backend())
        )
        
        logger.info(f"用户 '{username}' 的客户端证书生成完成")
        
        # ========== 保存文件 ==========
        # 构建文件路径
        client_key_path = os.path.join(output_dir, f'{username}-client.key')
        client_cert_path = os.path.join(output_dir, f'{username}-client.crt')
        
        logger.debug(f"开始保存用户 '{username}' 的客户端证书文件")
        
        # 保存客户端私钥
        client_key_pem = client_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.TraditionalOpenSSL,
            encryption_algorithm=serialization.NoEncryption(),
        )
        with open(client_key_path, 'wb') as f:
            f.write(client_key_pem)
        os.chmod(client_key_path, 0o600)
        logger.info(f"客户端私钥已保存: {client_key_path}")
        
        # 保存客户端证书
        client_cert_pem = client_cert.public_bytes(serialization.Encoding.PEM)
        with open(client_cert_path, 'wb') as f:
            f.write(client_cert_pem)
        os.chmod(client_cert_path, 0o644)
        logger.info(f"客户端证书已保存: {client_cert_path}")
        
        logger.info(f"用户 '{username}' 的客户端证书生成完成")
        return (client_cert_path, client_key_path)
        
    except Exception as e:
        logger.error(f"为用户 '{username}' 生成客户端证书失败: {e}")
        raise


def create_client_package(
    username: str,                  # 用户名
    secret: str,                    # 用户密钥
    server_host: str,               # 服务器主机名
    server_port: int,               # 服务器端口
    base_dir: str,                  # 基础目录路径
    output_dir: str,                # 输出目录路径
    key_size: int = 2048,           # RSA 密钥大小
    days_valid: int = 1095,         # 证书有效期（天）
    generate_certs: bool = True,       # 是否生成用户证书
    cert_info: dict = None           # 证书信息（client_cert, client_key）
) -> str:
    """
    创建包含配置文件和证书的 ZIP 包。
    
    为每个用户生成专属的客户端证书，提供更好的安全隔离。
    
    返回:
        创建的 ZIP 文件路径
    """
    logger.info(f"开始为用户 '{username}' 创建客户端包")
    
    # 创建临时目录用于打包
    with tempfile.TemporaryDirectory() as tmpdir:
        pkg_dir = os.path.join(tmpdir, username)  # 用户包目录
        os.makedirs(pkg_dir)                       # 创建目录
        
        # 生成用户专属证书（如果启用）
        if generate_certs:
            try:
                logger.info(f"为用户 '{username}' 生成专属证书")
                client_cert_path, client_key_path = generate_user_certificate(
                    username=username,
                    output_dir=pkg_dir,
                    key_size=key_size,
                    days_valid=days_valid
                )
                
                # 将生成的证书复制到包目录
                # 注意：generate_user_certificate 已经将证书保存到 pkg_dir
                logger.info(f"用户 '{username}' 的证书已生成并添加到包中")
                
            except Exception as e:
                logger.error(f"为用户 '{username}' 生成证书失败: {e}")
                raise Exception(f"证书生成失败: {e}")
        elif cert_info:
            # 使用提供的证书信息
            logger.info(f"使用提供的证书信息为用户 '{username}'")
            client_cert_path = os.path.join(pkg_dir, f'{username}-client.crt')
            client_key_path = os.path.join(pkg_dir, f'{username}-client.key')
            
            # 写入证书文件
            with open(client_cert_path, 'wb') as f:
                f.write(cert_info['client_cert'])
            os.chmod(client_cert_path, 0o644)
            logger.info(f"客户端证书已保存: {client_cert_path}")
            
            with open(client_key_path, 'wb') as f:
                f.write(cert_info['client_key'])
            os.chmod(client_key_path, 0o600)
            logger.info(f"客户端私钥已保存: {client_key_path}")
        
        # 生成客户端配置文件
        config_content = create_client_config(server_host, server_port, username, secret)
        config_filename = f"{username}-config.yaml"
        config_path = os.path.join(pkg_dir, config_filename)
        with open(config_path, 'w') as f:
            f.write(config_content)                   # 写入配置内容
        
        logger.info(f"配置文件已生成: {config_path}")

        # 创建 ZIP 文件
        zip_filename = f"{username}.zip"
        zip_path = os.path.abspath(os.path.join(output_dir, zip_filename))

        with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
            for root, dirs, files in os.walk(pkg_dir):
                for file in files:
                    file_path = os.path.join(root, file)       # 文件完整路径
                    arcname = os.path.relpath(file_path, tmpdir)  # ZIP 内的相对路径
                    zipf.write(file_path, arcname)             # 添加到 ZIP

        return zip_path


def main():
    parser = argparse.ArgumentParser(
        description='向 SMTP 隧道添加新用户',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
示例:
  %(prog)s alice                    # 添加用户 'alice' 并自动生成密钥
  %(prog)s bob --secret mysecret    # 添加用户 'bob' 并指定密钥
  %(prog)s carol --whitelist 1.2.3.4 --whitelist 10.0.0.0/8
  %(prog)s dave --no-logging        # 添加用户但不记录日志
"""
    )
    parser.add_argument('username', help='要添加的用户名')
    parser.add_argument('--secret', '-s', default=None, help='密钥（未提供则自动生成）')
    parser.add_argument('--whitelist', '-w', action='append', default=[], help='IP 白名单（可指定多个）')
    parser.add_argument('--no-logging', action='store_true', help='为此用户禁用日志记录')
    parser.add_argument('--users-file', '-u', default='/opt/smtp-tunnel/config/users.yaml', help='用户文件（默认: /opt/smtp-tunnel/config/users.yaml）')
    parser.add_argument('--config', '-c', default='/opt/smtp-tunnel/config/config.yaml', help='服务器配置文件（默认: /opt/smtp-tunnel/config/config.yaml）')
    parser.add_argument('--output-dir', '-o', default='.', help='ZIP 文件输出目录（默认: 当前目录）')
    parser.add_argument('--no-package', action='store_true', help='不生成客户端 ZIP 包')
    parser.add_argument('--no-certs', action='store_true', help='不为用户生成专属证书（使用全局 CA 证书）')
    parser.add_argument('--key-size', type=int, default=2048, help='RSA 密钥大小（位）（默认: 2048）')
    parser.add_argument('--cert-days', type=int, default=1095, help='证书有效期（天）（默认: 1095 = 3 年）')

    args = parser.parse_args()

    # 获取基础目录，查找项目文件
    base_dir = find_project_root()

    # 加载现有用户
    users_file = args.users_file
    if not os.path.isabs(users_file):
        users_file = os.path.join(base_dir, users_file)  # 转换为绝对路径

    users = load_users(users_file)  # 加载用户数据

    # 检查用户是否已存在
    if args.username in users:
        print(f"错误: 用户 '{args.username}' 已存在")
        return 1

    # 如果未提供密钥则生成
    secret = args.secret or generate_secret()

    # 创建用户配置（在内存中）
    user = UserConfig(
        username=args.username,
        secret=secret,
        whitelist=args.whitelist if args.whitelist else [],
        logging=not args.no_logging
    )

    # ========== 原子化执行开始 ==========
    # 先在内存中完成所有操作，确保数据一致性
    logger.info(f"开始为用户 '{args.username}' 执行原子化创建流程")
    
    try:
        # 步骤 1: 生成用户专属证书（如果启用）
        cert_info = None
        if not args.no_certs:
            logger.info(f"步骤 1/3: 为用户 '{args.username}' 生成专属证书")
            
            # 创建临时目录用于证书生成
            cert_output_dir = tempfile.mkdtemp(prefix=f'{args.username}-certs-')
            
            try:
                client_cert_path, client_key_path = generate_user_certificate(
                    username=args.username,
                    output_dir=cert_output_dir,
                    key_size=args.key_size,
                    days_valid=args.cert_days
                )
                
                # 读取证书内容到内存
                with open(client_cert_path, 'rb') as f:
                    client_cert_content = f.read()
                with open(client_key_path, 'rb') as f:
                    client_key_content = f.read()
                
                cert_info = {
                    'client_cert': client_cert_content,
                    'client_key': client_key_content
                }
                
                logger.info(f"步骤 1/3 完成: 用户 '{args.username}' 的证书已生成")
                
            except Exception as e:
                logger.error(f"步骤 1/3 失败: 证书生成失败 - {e}")
                raise Exception(f"证书生成失败: {e}")
            finally:
                # 清理临时目录
                shutil.rmtree(cert_output_dir, ignore_errors=True)
        else:
            logger.info(f"步骤 1/3: 跳过证书生成（使用 --no-certs 参数）")
        
        # 步骤 2: 保存用户到文件系统
        logger.info(f"步骤 2/3: 保存用户 '{args.username}' 到文件系统")
        users[args.username] = user
        save_users(users_file, users)
        logger.info(f"步骤 2/3 完成: 用户 '{args.username}' 已保存到 {users_file}")
        
        # 步骤 3: 生成客户端包（如果启用）
        if not args.no_package:
            logger.info(f"步骤 3/3: 为用户 '{args.username}' 生成客户端包")
            
            # 加载服务器配置以获取主机名和端口
            config_file = args.config
            if not os.path.isabs(config_file):
                config_file = os.path.join(base_dir, config_file)  # 转换为绝对路径

            try:
                config_data = load_config(config_file)            # 加载配置
                server_conf = config_data.get('server', {})
                server_host = server_conf.get('hostname', 'localhost')
                server_port = server_conf.get('port', 587)
            except FileNotFoundError:
                logger.warning(f"配置文件 {config_file} 未找到，使用默认值")
                server_host = 'localhost'
                server_port = 587

            output_dir = args.output_dir
            if not os.path.isabs(output_dir):
                output_dir = os.path.join(os.getcwd(), output_dir)  # 转换为绝对路径

            # 创建临时目录用于打包
            pkg_output_dir = tempfile.mkdtemp(prefix=f'{args.username}-pkg-')
            
            try:
                # 生成客户端包（包含用户证书）
                zip_path = create_client_package(
                    username=args.username,
                    secret=secret,
                    server_host=server_host,
                    server_port=server_port,
                    base_dir=pkg_output_dir,
                    output_dir=output_dir,
                    key_size=args.key_size,
                    days_valid=args.cert_days,
                    generate_certs=not args.no_certs,
                    cert_info=cert_info
                )
                
                logger.info(f"步骤 3/3 完成: 客户端包已创建 {zip_path}")
                
            except Exception as e:
                logger.error(f"步骤 3/3 失败: 客户端包生成失败 - {e}")
                raise Exception(f"客户端包生成失败: {e}")
            finally:
                # 清理临时目录
                shutil.rmtree(pkg_output_dir, ignore_errors=True)
        else:
            logger.info(f"步骤 3/3: 跳过客户端包生成（使用 --no-package 参数）")
        
        # ========== 原子化执行完成 ==========
        logger.info(f"用户 '{args.username}' 创建成功（原子化执行完成）")
        
        # 打印成功信息
        print(f"用户 '{args.username}' 已添加到 {users_file}")
        print()
        
        if not args.no_package:
            print(f"客户端包已创建: {zip_path}")
            print()
            print("将此 ZIP 文件发送给用户。包中包含:")
            print(f"  - {args.username}-config.yaml (配置文件)")
            if not args.no_certs:
                print(f"  - {args.username}-client.crt (客户端证书)")
                print(f"  - {args.username}-client.key (客户端私钥)")
            else:
                print("  - ca.crt (全局 CA 证书)")
            print()
            print("用户需要:")
            print("  1. 解压 ZIP 文件")
            print("  2. 下载客户端程序")
            print("  3. 使用配置文件和证书运行客户端")
        
        return 0
        
    except Exception as e:
        # ========== 原子化执行失败 ==========
        logger.error(f"用户 '{args.username}' 创建失败（原子化执行回滚）: {e}")
        
        # 回滚：从用户文件中移除用户
        if args.username in users:
            del users[args.username]
            try:
                save_users(users_file, users)
                logger.info(f"已回滚：从 {users_file} 中移除用户 '{args.username}'")
            except Exception as rollback_error:
                logger.error(f"回滚失败: {rollback_error}")
        
        print(f"错误: 用户 '{args.username}' 创建失败: {e}")
        return 1

if __name__ == '__main__':
    sys.exit(main())
