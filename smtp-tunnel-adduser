#!/usr/bin/env python3
"""
SMTP 隧道 - 添加用户脚本

创建新用户并生成客户端包 (ZIP 文件)

版本: 1.3.0

功能说明:
- 添加新用户到用户数据库
- 自动生成安全的随机密钥
- 创建包含客户端所需所有文件的 ZIP 包
- 生成客户端配置文件
- 创建 Windows 和 Linux/Mac 启动脚本
"""

import argparse
import os
import sys
import secrets
import zipfile
import tempfile
import shutil

# 将当前目录添加到导入路径
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from common import load_users, save_users, load_config, UserConfig


def generate_secret() -> str:
    """
    生成安全的随机密钥
    
    使用 secrets.token_urlsafe() 生成 URL 安全的随机字符串,
    适用于密码和认证令牌
    
    返回:
        str: 32 字节的 URL 安全随机字符串 (约 43 个字符)
    """
    return secrets.token_urlsafe(32)


def create_client_config(server_host: str, server_port: int, username: str, secret: str) -> str:
    """
    生成客户端配置文件内容
    
    参数:
        server_host: 服务器主机名或 IP 地址
        server_port: 服务器端口号
        username: 用户名
        secret: 用户密钥
        
    返回:
        str: YAML 格式的配置文件内容
    """
    return f"""# SMTP 隧道客户端配置
# 为用户生成: {username}

client:
  # 服务器连接配置
  server_host: "{server_host}"
  server_port: {server_port}

  # 认证信息
  username: "{username}"
  secret: "{secret}"

  # 本地 SOCKS5 代理配置
  socks_port: 1080
  socks_host: "127.0.0.1"

  # 用于服务器验证的 CA 证书
  ca_cert: "ca.crt"
"""


def create_client_package(
    username: str,
    secret: str,
    server_host: str,
    server_port: int,
    base_dir: str,
    output_dir: str
) -> str:
    """
    创建包含客户端所需所有文件的 ZIP 包
    
    包含以下文件:
    - client.py: 客户端程序
    - common.py: 共享库
    - requirements.txt: Python 依赖
    - config.yaml: 预配置的客户端配置
    - ca.crt: 服务器 CA 证书 (如果存在)
    - start.bat: Windows 启动脚本
    - start.sh: Linux/Mac 启动脚本
    - README.txt: 用户使用说明
    
    参数:
        username: 用户名
        secret: 用户密钥
        server_host: 服务器主机名
        server_port: 服务器端口
        base_dir: 基础目录 (包含客户端文件)
        output_dir: 输出目录
        
    返回:
        str: 创建的 ZIP 文件路径
    """
    # 需要从基础目录包含的文件
    client_files = ['client.py', 'common.py', 'requirements.txt']

    # 检查 ca.crt 是否存在
    ca_cert_path = os.path.join(base_dir, 'ca.crt')
    has_ca_cert = os.path.exists(ca_cert_path)

    # 创建临时目录用于打包
    with tempfile.TemporaryDirectory() as tmpdir:
        pkg_dir = os.path.join(tmpdir, username)
        os.makedirs(pkg_dir)

        # 复制客户端文件
        for filename in client_files:
            src = os.path.join(base_dir, filename)
            if os.path.exists(src):
                shutil.copy(src, pkg_dir)
            else:
                print(f"警告: {filename} 未找到,跳过")

        # 如果存在 CA 证书则复制
        if has_ca_cert:
            shutil.copy(ca_cert_path, pkg_dir)
        else:
            print("警告: ca.crt 未找到 - 客户端将无法验证服务器")

        # 生成客户端配置
        config_content = create_client_config(server_host, server_port, username, secret)
        config_path = os.path.join(pkg_dir, 'config.yaml')
        with open(config_path, 'w') as f:
            f.write(config_content)

        # 为用户创建 README 文件
        readme_content = f"""# SMTP 隧道客户端 - {username}

## 快速开始

1. 安装依赖:
   pip install -r requirements.txt

2. 运行客户端:
   python client.py

3. 配置浏览器/应用使用 SOCKS5 代理:
   主机: 127.0.0.1
   端口: 1080

## 文件说明

- start.bat      - Windows 启动器 (双击运行)
- start.sh       - Linux/Mac 启动器 (使用 ./start.sh 运行)
- client.py      - 隧道客户端程序
- common.py      - 共享库
- config.yaml    - 您的配置文件 (已预配置)
- ca.crt         - 用于验证的服务器证书
- requirements.txt - Python 依赖包

## 测试连接

curl -x socks5h://127.0.0.1:1080 https://ifconfig.me

## 简单启动

Windows: 双击 start.bat
Linux/Mac: 运行 ./start.sh
"""
        readme_path = os.path.join(pkg_dir, 'README.txt')
        with open(readme_path, 'w') as f:
            f.write(readme_content)

        # 创建 Windows 启动脚本 (start.bat)
        bat_content = f'''@echo off
chcp 65001 >nul 2>&1
title SMTP 隧道 - {username}

echo.
echo  ╔═══════════════════════════════════════════════════════════╗
echo  ║                                                           ║
echo  ║   ███████╗███╗   ███╗████████╗██████╗                     ║
echo  ║   ██╔════╝████╗ ████║╚══██╔══╝██╔══██╗                    ║
echo  ║   ███████╗██╔████╔██║   ██║   ██████╔╝                    ║
echo  ║   ╚════██║██║╚██╔╝██║   ██║   ██╔═══╝                     ║
echo  ║   ███████║██║ ╚═╝ ██║   ██║   ██║                         ║
echo  ║   ╚══════╝╚═╝     ╚═╝   ╚═╝   ╚═╝                         ║
echo  ║                                                           ║
echo  ║   SMTP 隧道代理客户端                                 ║
echo  ║   用户: {username:50}║
echo  ║                                                           ║
echo  ╚═══════════════════════════════════════════════════════════╝
echo.

:: 检查 Python
where python >nul 2>&1
if %errorlevel% neq 0 (
    where python3 >nul 2>&1
    if %errorlevel% neq 0 (
        echo [错误] 未找到 Python!
        echo.
        echo 请从以下地址安装 Python 3.8+:
        echo   https://www.python.org/downloads/
        echo.
        echo 确保在安装过程中勾选 "Add Python to PATH"。
        echo.
        pause
        exit /b 1
    )
    set PYTHON=python3
) else (
    set PYTHON=python
)

echo [信息] 找到 Python: %PYTHON%

:: 检查Python虚拟环境工具
echo [信息] 正在检查Python虚拟环境工具...
%PYTHON% -c "import venv" >nul 2>&1
if %errorlevel% neq 0 (
    echo [错误] Python虚拟环境工具(venv)不可用!
    echo.
    echo 请确保您的Python版本支持venv模块(Python 3.3+)
    echo 或使用以下命令安装:
    echo   pip install virtualenv
    echo.
    pause
    exit /b 1
)
echo [信息] Python虚拟环境工具检查通过

:: 检查是否已存在虚拟环境
if exist ".venv\Scripts\activate.bat" (
    echo [信息] 检测到已存在的虚拟环境 .venv
) else (
    echo [信息] 正在创建Python虚拟环境...
    %PYTHON% -m venv .venv
    if %errorlevel% neq 0 (
        echo [错误] 虚拟环境创建失败!
        echo.
        echo 请检查Python安装是否完整,或尝试手动创建虚拟环境:
        echo   python -m venv .venv
        echo.
        pause
        exit /b 1
    )
    echo [信息] 虚拟环境创建成功
)

:: 激活虚拟环境
echo [信息] 正在激活虚拟环境...
call .venv\Scripts\activate.bat
if %errorlevel% neq 0 (
    echo [错误] 虚拟环境激活失败!
    echo.
    echo 请检查.venv目录是否存在且完整
    echo.
    pause
    exit /b 1
)
echo [信息] 虚拟环境已激活

:: 检查/安装依赖
echo [信息] 正在检查依赖...
python -c "import yaml" >nul 2>&1
if %errorlevel% neq 0 (
    echo [信息] 正在安装依赖...
    python -m pip install -r requirements.txt --quiet
    if %errorlevel% neq 0 (
        echo [错误] 依赖安装失败
        echo.
        echo 尝试手动运行: python -m pip install -r requirements.txt
        echo.
        pause
        exit /b 1
    )
    echo [信息] 依赖已安装
)

echo.
echo [信息] 正在启动 SMTP 隧道...
echo [信息] SOCKS5 代理将在 127.0.0.1:1080 可用
echo.
echo 按 Ctrl+C 停止
echo ─────────────────────────────────────────────────────────────
echo.

python client.py

echo.
echo 连接已关闭。
echo 按任意键退出...
pause >nul
'''
        bat_path = os.path.join(pkg_dir, 'start.bat')
        with open(bat_path, 'w', newline='\r\n') as f:
            f.write(bat_content)

        # 创建 Linux/Mac 启动脚本 (start.sh)
        sh_content = f'''#!/bin/bash
#
# SMTP 隧道客户端启动器
# 用户: {username}
#

# 颜色定义
RED='\\033[0;31m'
GREEN='\\033[0;32m'
YELLOW='\\033[1;33m'
BLUE='\\033[0;34m'
CYAN='\\033[0;36m'
NC='\\033[0m'

clear
echo ""
echo -e "${{CYAN}}"
echo "  ╔═══════════════════════════════════════════════════════════╗"
echo "  ║                                                           ║"
echo "  ║   ███████╗███╗   ███╗████████╗██████╗                     ║"
echo "  ║   ██╔════╝████╗ ████║╚══██╔══╝██╔══██╗                    ║"
echo "  ║   ███████╗██╔████╔██║   ██║   ██████╔╝                    ║"
echo "  ║   ╚════██║██║╚██╔╝██║   ██║   ██╔═══╝                     ║"
echo "  ║   ███████║██║ ╚═╝ ██║   ██║   ██║                         ║"
echo "  ║   ╚══════╝╚═╝     ╚═╝   ╚═╝   ╚═╝                         ║"
echo "  ║                                                           ║"
echo "  ║   SMTP 隧道代理客户端                                 ║"
echo "  ║   用户: {username:50}║"
echo "  ║                                                           ║"
echo "  ╚═══════════════════════════════════════════════════════════╝"
echo -e "${{NC}}"
echo ""

# 查找 Python
if command -v python3 &> /dev/null; then
    PYTHON=python3
elif command -v python &> /dev/null; then
    PYTHON=python
else
    echo -e "${{RED}}[错误]${{NC}} 未找到 Python!"
    echo ""
    echo "请安装 Python 3.8+:"
    echo "  Ubuntu/Debian: sudo apt install python3 python3-pip"
    echo "  macOS: brew install python3"
    echo "  或从以下地址下载: https://www.python.org/downloads/"
    echo ""
    exit 1
fi

echo -e "${{GREEN}}[信息]${{NC}} 找到 Python: $PYTHON"

# 检查Python虚拟环境工具
echo -e "${{GREEN}}[信息]${{NC}} 正在检查Python虚拟环境工具..."
if ! $PYTHON -c "import venv" &> /dev/null; then
    echo -e "${{RED}}[错误]${{NC}} Python虚拟环境工具(venv)不可用!"
    echo ""
    echo "请确保您的Python版本支持venv模块(Python 3.3+)"
    echo "或使用以下命令安装:"
    echo "  pip install virtualenv"
    echo ""
    exit 1
fi
echo -e "${{GREEN}}[信息]${{NC}} Python虚拟环境工具检查通过"

# 检查是否已存在虚拟环境
if [ -f ".venv/bin/activate" ]; then
    echo -e "${{GREEN}}[信息]${{NC}} 检测到已存在的虚拟环境 .venv"
else
    echo -e "${{GREEN}}[信息]${{NC}} 正在创建Python虚拟环境..."
    $PYTHON -m venv .venv
    if [ $? -ne 0 ]; then
        echo -e "${{RED}}[错误]${{NC}} 虚拟环境创建失败!"
        echo ""
        echo "请检查Python安装是否完整,或尝试手动创建虚拟环境:"
        echo "  python -m venv .venv"
        echo ""
        exit 1
    fi
    echo -e "${{GREEN}}[信息]${{NC}} 虚拟环境创建成功"
fi

# 激活虚拟环境
echo -e "${{GREEN}}[信息]${{NC}} 正在激活虚拟环境..."
source .venv/bin/activate
if [ $? -ne 0 ]; then
    echo -e "${{RED}}[错误]${{NC}} 虚拟环境激活失败!"
    echo ""
    echo "请检查.venv目录是否存在且完整"
    echo ""
    exit 1
fi
echo -e "${{GREEN}}[信息]${{NC}} 虚拟环境已激活"

# 检查/安装依赖
echo -e "${{GREEN}}[信息]${{NC}} 正在检查依赖..."
if ! python -c "import yaml" &> /dev/null; then
    echo -e "${{YELLOW}}[信息]${{NC}} 正在安装依赖..."
    python -m pip install -r requirements.txt --quiet
    if [ $? -ne 0 ]; then
        echo -e "${{RED}}[错误]${{NC}} 依赖安装失败"
        echo "尝试运行: python -m pip install -r requirements.txt"
        exit 1
    fi
    echo -e "${{GREEN}}[信息]${{NC}} 依赖已安装"
fi

echo ""
echo -e "${{GREEN}}[信息]${{NC}} 正在启动 SMTP 隧道..."
echo -e "${{GREEN}}[信息]${{NC}} SOCKS5 代理将在 127.0.0.1:1080 可用"
echo ""
echo -e "按 ${{YELLOW}}Ctrl+C${{NC}} 停止"
echo "─────────────────────────────────────────────────────────────"
echo ""

python client.py

echo ""
echo -e "${{YELLOW}}连接已关闭。${{NC}}"
'''
        sh_path = os.path.join(pkg_dir, 'start.sh')
        with open(sh_path, 'w') as f:
            f.write(sh_content)
        os.chmod(sh_path, 0o755)  # 设置可执行权限

        # 创建 ZIP 文件
        zip_filename = f"{username}.zip"
        zip_path = os.path.abspath(os.path.join(output_dir, zip_filename))

        with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
            for root, dirs, files in os.walk(pkg_dir):
                for file in files:
                    file_path = os.path.join(root, file)
                    arcname = os.path.relpath(file_path, tmpdir)
                    zipf.write(file_path, arcname)

        return zip_path


def main():
    """
    主函数 - 解析命令行参数并添加新用户
    
    命令行参数:
        username: 要添加的用户名 (必需)
        --secret, -s: 用户密钥 (未提供则自动生成)
        --whitelist, -w: IP 白名单 (可多次指定)
        --no-logging: 禁用该用户的日志记录
        --users-file, -u: 用户文件路径
        --config, -c: 服务器配置文件路径
        --output-dir, -o: ZIP 文件输出目录
        --no-package: 不生成客户端 ZIP 包
    """
    parser = argparse.ArgumentParser(
        description='向 SMTP 隧道添加新用户',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
示例:
  %(prog)s alice                    # 添加用户 'alice',自动生成密钥
  %(prog)s bob --secret mysecret    # 添加用户 'bob',使用指定密钥
  %(prog)s carol --whitelist 1.2.3.4 --whitelist 10.0.0.0/8
  %(prog)s dave --no-logging        # 添加用户,不记录日志
"""
    )
    parser.add_argument('username', help='要添加的用户名')
    parser.add_argument('--secret', '-s', default=None, help='用户密钥 (未提供则自动生成)')
    parser.add_argument('--whitelist', '-w', action='append', default=[], help='IP 白名单 (可多次指定)')
    parser.add_argument('--no-logging', action='store_true', help='禁用该用户的日志记录')
    parser.add_argument('--users-file', '-u', default='/etc/smtp-tunnel/users.yaml', help='用户文件 (默认: /etc/smtp-tunnel/users.yaml)')
    parser.add_argument('--config', '-c', default='/etc/smtp-tunnel/config.yaml', help='服务器配置文件 (默认: /etc/smtp-tunnel/config.yaml)')
    parser.add_argument('--output-dir', '-o', default='.', help='ZIP 文件输出目录 (默认: 当前目录)')
    parser.add_argument('--no-package', action='store_true', help='不生成客户端 ZIP 包')

    args = parser.parse_args()

    # 获取基础目录 (此脚本所在目录)
    base_dir = os.path.dirname(os.path.abspath(__file__))

    # 加载现有用户
    users_file = args.users_file
    if not os.path.isabs(users_file):
        users_file = os.path.join(base_dir, users_file)

    users = load_users(users_file)

    # 检查用户是否已存在
    if args.username in users:
        print(f"错误: 用户 '{args.username}' 已存在")
        return 1

    # 如果未提供密钥则生成
    secret = args.secret or generate_secret()

    # 创建用户配置
    user = UserConfig(
        username=args.username,
        secret=secret,
        whitelist=args.whitelist if args.whitelist else [],
        logging=not args.no_logging
    )

    # 添加用户
    users[args.username] = user

    # 保存用户文件
    save_users(users_file, users)
    print(f"用户 '{args.username}' 已添加到 {users_file}")

    # 生成客户端包
    if not args.no_package:
        # 加载服务器配置以获取主机名和端口
        config_file = args.config
        if not os.path.isabs(config_file):
            config_file = os.path.join(base_dir, config_file)

        try:
            config_data = load_config(config_file)
            server_conf = config_data.get('server', {})
            server_host = server_conf.get('hostname', 'localhost')
            server_port = server_conf.get('port', 587)
        except FileNotFoundError:
            print(f"警告: 配置文件 {config_file} 未找到,使用默认值")
            server_host = 'localhost'
            server_port = 587

        output_dir = args.output_dir
        if not os.path.isabs(output_dir):
            output_dir = os.path.join(os.getcwd(), output_dir)

        zip_path = create_client_package(
            username=args.username,
            secret=secret,
            server_host=server_host,
            server_port=server_port,
            base_dir=base_dir,
            output_dir=output_dir
        )

        print(f"客户端包已创建: {zip_path}")
        print()
        print("将此 ZIP 文件发送给用户。他们只需要:")
        print("  1. 解压 ZIP 文件")
        print("  2. pip install -r requirements.txt")
        print("  3. python client.py")

    return 0


if __name__ == '__main__':
    sys.exit(main())
