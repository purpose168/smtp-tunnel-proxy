#!/bin/bash
#
# SMTP 隧道代理 - 客户端更新脚本
#
# 更新客户端文件，不影响配置、证书或日志。
#
# 版本: 1.3.0
#
# 功能说明:
#   1. 版本检查 - 检查当前版本和最新版本
#   2. 下载更新包 - 从 GitHub 下载最新版本
#   3. 文件校验 - 验证下载文件的完整性
#   4. 备份当前版本 - 在更新前备份当前文件
#   5. 更新文件 - 替换程序文件
#   6. 更新依赖 - 更新 Python 依赖包
#   7. 重启服务 - 重启客户端服务
#   8. 回滚机制 - 更新失败时自动回滚
#   9. 日志记录 - 详细记录更新过程
#

# ============================================================================
# 配置区域
# ============================================================================

# 颜色定义
RED='\033[0;31m'      # 红色 - 错误
GREEN='\033[0;32m'    # 绿色 - 信息
YELLOW='\033[1;33m'   # 黄色 - 警告
BLUE='\033[0;34m'     # 蓝色 - 步骤
CYAN='\033[0;36m'     # 青色 - 调试
NC='\033[0m'          # 无颜色

# GitHub 原始文件 URL
GITHUB_RAW="https://raw.githubusercontent.com/purpose168/smtp-tunnel-proxy/main"
GITHUB_API="https://api.github.com/repos/purpose168/smtp-tunnel-proxy/releases/latest"

# 获取脚本所在目录
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# 安装目录（客户端通常安装在用户目录下）
INSTALL_DIR="$SCRIPT_DIR"           # 程序安装目录
CONFIG_DIR="$SCRIPT_DIR/config"      # 配置文件目录
VENV_DIR="$SCRIPT_DIR/venv"         # Python 虚拟环境目录
LOG_DIR="$SCRIPT_DIR/logs"           # 日志目录
BACKUP_DIR="$SCRIPT_DIR/backups"     # 备份目录

# 日志文件
UPDATE_LOG="$LOG_DIR/client-update.log"

# 临时目录
TEMP_DIR="/tmp/smtp-tunnel-client-update"

# 要更新的文件（仅代码 - 不包括配置/证书/日志）
# 主入口文件
CLIENT_FILES="client.py socks5_server.py"

# 协议模块
PROTOCOL_MODULES="protocol/__init__.py protocol/core.py protocol/client.py"

# 隧道模块
TUNNEL_MODULES="tunnel/__init__.py tunnel/crypto.py tunnel/base.py tunnel/client.py"

# 其他模块
OTHER_MODULES="connection.py config.py logger.py"

# 所有需要更新的文件
UPDATE_FILES="$CLIENT_FILES $PROTOCOL_MODULES $TUNNEL_MODULES $OTHER_MODULES"

# 更新配置
MAX_RETRIES=3              # 最大重试次数
RETRY_DELAY=2              # 重试延迟（秒）
BACKUP_RETENTION_DAYS=7    # 备份保留天数

# 调试模式
DEBUG_MODE="${DEBUG_MODE:-false}"

# ============================================================================
# 日志记录函数
# ============================================================================

# 打印信息消息
print_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
    log_message "INFO" "$1"
}

# 打印警告消息
print_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
    log_message "WARN" "$1"
}

# 打印错误消息
print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
    log_message "ERROR" "$1"
}

# 打印步骤消息
print_step() {
    echo -e "${BLUE}[STEP]${NC} $1"
    log_message "INFO" "$1"
}

# 打印调试消息
print_debug() {
    if [ "$DEBUG_MODE" = "true" ]; then
        echo -e "${CYAN}[DEBUG]${NC} $1"
    fi
    log_message "DEBUG" "$1"
}

# 打印进度消息
print_progress() {
    local current=$1
    local total=$2
    local message=$3
    local percent=$((current * 100 / total))
    echo -e "${GREEN}[${percent}%]${NC} $message"
    log_message "INFO" "进度: $current/$total - $message"
}

# 日志记录函数
log_message() {
    local level=$1
    local message=$2
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    # 确保日志目录存在
    mkdir -p "$LOG_DIR" 2>/dev/null
    
    # 写入日志文件
    echo "[$timestamp] [$level] $message" >> "$UPDATE_LOG" 2>/dev/null || true
}

# 记录更新开始
log_update_start() {
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "" >> "$UPDATE_LOG"
    echo "========================================" >> "$UPDATE_LOG"
    echo "[$timestamp] [INFO] 开始客户端更新" >> "$UPDATE_LOG"
    echo "========================================" >> "$UPDATE_LOG"
    log_message "INFO" "脚本目录: $SCRIPT_DIR"
    log_message "INFO" "安装目录: $INSTALL_DIR"
    log_message "INFO" "配置目录: $CONFIG_DIR"
    log_message "INFO" "虚拟环境: $VENV_DIR"
    log_message "INFO" "日志目录: $LOG_DIR"
    log_message "INFO" "备份目录: $BACKUP_DIR"
}

# 记录更新结束
log_update_end() {
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "========================================" >> "$UPDATE_LOG"
    echo "[$timestamp] [INFO] 客户端更新完成" >> "$UPDATE_LOG"
    echo "========================================" >> "$UPDATE_LOG"
    echo "" >> "$UPDATE_LOG"
}

# 记录更新成功
log_update_success() {
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "========================================" >> "$UPDATE_LOG"
    echo "[$timestamp] [SUCCESS] 客户端更新成功" >> "$UPDATE_LOG"
    echo "========================================" >> "$UPDATE_LOG"
    echo "" >> "$UPDATE_LOG"
}

# 记录更新失败
log_update_failure() {
    local reason=$1
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "========================================" >> "$UPDATE_LOG"
    echo "[$timestamp] [FAILURE] 客户端更新失败: $reason" >> "$UPDATE_LOG"
    echo "========================================" >> "$UPDATE_LOG"
    echo "" >> "$UPDATE_LOG"
}

# ============================================================================
# 检查函数
# ============================================================================

# 检查命令是否存在
check_command() {
    local cmd=$1
    if ! command -v "$cmd" &> /dev/null; then
        print_error "命令 '$cmd' 未找到，请先安装"
        log_message "ERROR" "命令 '$cmd' 不存在"
        return 1
    fi
    print_debug "命令 '$cmd' 检查通过"
    return 0
}

# 检查安装是否存在
check_installation() {
    if [ ! -f "$INSTALL_DIR/client.py" ]; then
        print_error "SMTP 隧道客户端未安装在 $INSTALL_DIR"
        print_error "请先运行安装程序: curl -sSL $GITHUB_RAW/install-client.sh | bash"
        log_message "ERROR" "客户端文件不存在: $INSTALL_DIR/client.py"
        return 1
    fi
    print_debug "客户端安装检查通过: $INSTALL_DIR"
    return 0
}

# 检查日志目录
check_log_directory() {
    if [ ! -d "$LOG_DIR" ]; then
        mkdir -p "$LOG_DIR"
        chmod 755 "$LOG_DIR"
        print_info "已创建日志目录: $LOG_DIR"
    fi
    print_debug "日志目录检查通过: $LOG_DIR"
}

# 检查备份目录
check_backup_directory() {
    if [ ! -d "$BACKUP_DIR" ]; then
        mkdir -p "$BACKUP_DIR"
        chmod 755 "$BACKUP_DIR"
        print_info "已创建备份目录: $BACKUP_DIR"
    fi
    print_debug "备份目录检查通过: $BACKUP_DIR"
}

# 检查网络连接
check_network() {
    print_step "检查网络连接..."
    
    if ! check_command "curl"; then
        return 1
    fi
    
    # 测试 GitHub 连接
    if curl -sSL --connect-timeout 10 --max-time 30 "$GITHUB_RAW/client.py" > /dev/null 2>&1; then
        print_info "网络连接正常"
        log_message "INFO" "网络连接检查通过"
        return 0
    else
        print_error "无法连接到 GitHub，请检查网络连接"
        log_message "ERROR" "网络连接检查失败"
        return 1
    fi
}

# ============================================================================
# 版本管理函数
# ============================================================================

# 获取当前版本
get_current_version() {
    if [ -f "$INSTALL_DIR/client.py" ]; then
        CURRENT_VERSION=$(grep -m1 "Version:" "$INSTALL_DIR/client.py" | sed 's/.*Version: //')
        echo "$CURRENT_VERSION"
    else
        echo "未知"
    fi
}

# 获取最新版本（从 GitHub API）
get_latest_version() {
    print_step "检查最新版本..."
    
    local latest_version=""
    local retry_count=0
    
    while [ $retry_count -lt $MAX_RETRIES ]; do
        if latest_version=$(curl -sSL --connect-timeout 10 --max-time 30 "$GITHUB_API" 2>/dev/null | grep '"tag_name"' | head -n 1 | sed 's/.*"tag_name": "\(.*\)".*/\1/'); then
            if [ -n "$latest_version" ]; then
                print_info "最新版本: $latest_version"
                log_message "INFO" "最新版本: $latest_version"
                echo "$latest_version"
                return 0
            fi
        fi
        
        retry_count=$((retry_count + 1))
        if [ $retry_count -lt $MAX_RETRIES ]; then
            print_warn "获取版本信息失败，重试 $retry_count/$MAX_RETRIES..."
            sleep $RETRY_DELAY
        fi
    done
    
    print_warn "无法获取最新版本信息，将继续更新"
    log_message "WARN" "无法获取最新版本信息"
    echo "未知"
    return 1
}

# 比较版本
compare_versions() {
    local current=$1
    local latest=$2
    
    if [ "$current" = "$latest" ]; then
        echo "same"
    elif [ "$current" = "未知" ] || [ "$latest" = "未知" ]; then
        echo "unknown"
    else
        # 简单版本比较（假设格式为 x.y.z）
        if [ "$current" != "$latest" ]; then
            echo "different"
        else
            echo "same"
        fi
    fi
}

# 显示版本信息
show_version_info() {
    local current_ver=$(get_current_version)
    local latest_ver=$(get_latest_version)
    
    echo ""
    echo -e "${BLUE}版本信息:${NC}"
    echo "  当前版本: $current_ver"
    echo "  最新版本: $latest_ver"
    echo ""
    
    log_message "INFO" "当前版本: $current_ver"
    log_message "INFO" "最新版本: $latest_ver"
}

# ============================================================================
# 备份函数
# ============================================================================

# 创建备份
create_backup() {
    print_step "创建备份..."
    
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_path="$BACKUP_DIR/backup_$timestamp"
    
    mkdir -p "$backup_path"
    
    local backup_count=0
    
    # 备份所有更新文件
    for file in $UPDATE_FILES; do
        if [ -f "$INSTALL_DIR/$file" ]; then
            local dest_dir="$backup_path/$(dirname "$file")"
            mkdir -p "$dest_dir"
            cp "$INSTALL_DIR/$file" "$backup_path/$file"
            backup_count=$((backup_count + 1))
            print_debug "已备份: $file"
        fi
    done
    
    # 备份管理脚本
    if [ -f "$INSTALL_DIR/start.sh" ]; then
        cp "$INSTALL_DIR/start.sh" "$backup_path/"
        backup_count=$((backup_count + 1))
    fi
    
    if [ -f "$INSTALL_DIR/stop.sh" ]; then
        cp "$INSTALL_DIR/stop.sh" "$backup_path/"
        backup_count=$((backup_count + 1))
    fi
    
    if [ -f "$INSTALL_DIR/status.sh" ]; then
        cp "$INSTALL_DIR/status.sh" "$backup_path/"
        backup_count=$((backup_count + 1))
    fi
    
    # 保存备份路径到文件，用于回滚
    echo "$backup_path" > "$BACKUP_DIR/last_backup.txt"
    
    print_info "备份完成: $backup_path ($backup_count 个文件)"
    log_message "INFO" "备份创建完成: $backup_path ($backup_count 个文件)"
    
    echo "$backup_path"
}

# 清理旧备份
cleanup_old_backups() {
    print_step "清理旧备份..."
    
    local cleanup_count=0
    
    # 查找并删除超过保留期的备份
    for backup in "$BACKUP_DIR"/backup_*; do
        if [ -d "$backup" ]; then
            local backup_age=$(( ($(date +%s) - $(stat -c %Y "$backup" 2>/dev/null || echo 0)) / 86400 ))
            
            if [ $backup_age -gt $BACKUP_RETENTION_DAYS ]; then
                rm -rf "$backup"
                cleanup_count=$((cleanup_count + 1))
                print_debug "已删除旧备份: $backup"
            fi
        fi
    done
    
    if [ $cleanup_count -gt 0 ]; then
        print_info "已清理 $cleanup_count 个旧备份"
        log_message "INFO" "已清理 $cleanup_count 个旧备份"
    else
        print_debug "无需清理旧备份"
    fi
}

# ============================================================================
# 更新函数
# ============================================================================

# 下载文件
download_file() {
    local file=$1
    local dest=$2
    local url="$GITHUB_RAW/$file"
    
    local retry_count=0
    
    while [ $retry_count -lt $MAX_RETRIES ]; do
        if curl -sSL -f --connect-timeout 10 --max-time 60 "$url" -o "$dest" 2>/dev/null; then
            return 0
        fi
        
        retry_count=$((retry_count + 1))
        if [ $retry_count -lt $MAX_RETRIES ]; then
            print_warn "下载失败，重试 $retry_count/$MAX_RETRIES: $file"
            sleep $RETRY_DELAY
        fi
    done
    
    return 1
}

# 校验文件
verify_file() {
    local file=$1
    
    # 检查文件是否存在
    if [ ! -f "$file" ]; then
        print_error "文件不存在: $file"
        return 1
    fi
    
    # 检查文件大小
    local file_size=$(stat -c %s "$file" 2>/dev/null || echo 0)
    if [ $file_size -eq 0 ]; then
        print_error "文件为空: $file"
        return 1
    fi
    
    # 对于 Python 文件，检查是否包含基本的 Python 语法
    if [[ "$file" == *.py ]]; then
        if ! python3 -m py_compile "$file" 2>/dev/null; then
            print_error "文件语法错误: $file"
            return 1
        fi
    fi
    
    print_debug "文件校验通过: $file"
    return 0
}

# 更新文件
update_files() {
    print_step "正在更新程序文件..."
    log_message "INFO" "开始下载更新文件"
    
    cd "$INSTALL_DIR"
    
    local total_files=$(echo $UPDATE_FILES | wc -w)
    local current_file=0
    local success_count=0
    local fail_count=0
    FAILED=0
    
    # 创建临时目录
    mkdir -p "$TEMP_DIR"
    
    for file in $UPDATE_FILES; do
        current_file=$((current_file + 1))
        print_progress $current_file $total_files "正在下载: $file"
        
        local temp_file="$TEMP_DIR/$(basename "$file")"
        
        # 下载文件
        if download_file "$file" "$temp_file"; then
            # 校验文件
            if verify_file "$temp_file"; then
                # 创建目标目录
                local dest_dir=$(dirname "$file")
                mkdir -p "$dest_dir"
                
                # 移动文件
                mv "$temp_file" "$file"
                
                print_debug "更新成功: $file"
                log_message "INFO" "更新成功: $file"
                success_count=$((success_count + 1))
            else
                print_warn "文件校验失败: $file"
                log_message "WARN" "文件校验失败: $file"
                rm -f "$temp_file"
                fail_count=$((fail_count + 1))
                FAILED=1
            fi
        else
            print_warn "下载失败: $file"
            log_message "WARN" "下载失败: $file"
            rm -f "$temp_file"
            fail_count=$((fail_count + 1))
            FAILED=1
        fi
    done
    
    # 清理临时目录
    rm -rf "$TEMP_DIR"
    
    print_info "更新完成: $success_count 个文件成功, $fail_count 个文件失败"
    log_message "INFO" "文件更新完成: $success_count 成功, $fail_count 失败"
    
    return $FAILED
}

# 更新管理脚本
update_management_scripts() {
    print_step "更新管理脚本..."
    
    local scripts="start.sh stop.sh status.sh"
    local success_count=0
    
    for script in $scripts; do
        if download_file "$script" "$TEMP_DIR/$script"; then
            if verify_file "$TEMP_DIR/$script"; then
                mv "$TEMP_DIR/$script" "$INSTALL_DIR/$script"
                chmod +x "$INSTALL_DIR/$script"
                success_count=$((success_count + 1))
                print_debug "更新成功: $script"
            fi
        fi
    done
    
    print_info "管理脚本更新完成: $success_count 个脚本"
    log_message "INFO" "管理脚本更新完成"
}

# 设置文件权限
set_permissions() {
    print_step "正在设置文件权限..."
    
    # 设置 Python 文件权限
    find "$INSTALL_DIR" -name "*.py" -exec chmod 644 {} \;
    
    # 设置目录权限
    find "$INSTALL_DIR" -type d -exec chmod 755 {} \;
    
    # 设置管理脚本执行权限
    chmod +x "$INSTALL_DIR/start.sh" 2>/dev/null || true
    chmod +x "$INSTALL_DIR/stop.sh" 2>/dev/null || true
    chmod +x "$INSTALL_DIR/status.sh" 2>/dev/null || true
    
    print_info "文件权限已设置"
    log_message "INFO" "文件权限设置完成"
}

# ============================================================================
# 依赖管理函数
# ============================================================================

# 检查虚拟环境
check_venv() {
    if [ -d "$VENV_DIR" ]; then
        print_debug "虚拟环境存在: $VENV_DIR"
        return 0
    else
        print_warn "虚拟环境不存在: $VENV_DIR"
        log_message "WARN" "虚拟环境不存在: $VENV_DIR"
        return 1
    fi
}

# 更新 Python 包
update_python_packages() {
    print_step "正在检查 Python 包更新..."
    
    if ! check_venv; then
        print_warn "虚拟环境不存在，跳过 Python 包更新"
        return 1
    fi
    
    # 激活虚拟环境
    source "$VENV_DIR/bin/activate"
    
    # 升级 pip
    print_info "升级 pip..."
    if pip install --upgrade pip 2>/dev/null; then
        print_info "pip 升级成功"
        log_message "INFO" "pip 升级成功"
    else
        print_warn "pip 升级失败"
        log_message "WARN" "pip 升级失败"
    fi
    
    # 更新依赖包
    print_info "更新依赖包..."
    if [ -f "$INSTALL_DIR/requirements.txt" ]; then
        if pip install -r "$INSTALL_DIR/requirements.txt" 2>/dev/null; then
            print_info "Python 包已更新"
            log_message "INFO" "Python 包更新完成"
        else
            print_warn "Python 包更新失败（可能无需更新）"
            log_message "WARN" "Python 包更新失败"
        fi
    else
        print_warn "requirements.txt 不存在，跳过依赖更新"
        log_message "WARN" "requirements.txt 不存在"
    fi
    
    # 停用虚拟环境
    deactivate 2>/dev/null || true
    
    return 0
}

# ============================================================================
# 服务管理函数
# ============================================================================

# 停止客户端
stop_client() {
    print_step "正在停止客户端..."
    
    # 尝试使用 stop.sh 脚本
    if [ -f "$INSTALL_DIR/stop.sh" ]; then
        "$INSTALL_DIR/stop.sh" 2>/dev/null
        sleep 2
    fi
    
    # 检查进程是否还在运行
    if [ -f "$INSTALL_DIR/client.pid" ]; then
        local pid=$(cat "$INSTALL_DIR/client.pid")
        if kill -0 "$pid" 2>/dev/null; then
            kill "$pid" 2>/dev/null || true
            sleep 2
        fi
    fi
    
    print_info "客户端已停止"
    log_message "INFO" "客户端已停止"
}

# 启动客户端
start_client() {
    print_step "正在启动客户端..."
    
    # 尝试使用 start.sh 脚本
    if [ -f "$INSTALL_DIR/start.sh" ]; then
        "$INSTALL_DIR/start.sh" 2>/dev/null
        sleep 2
        
        # 检查进程是否启动
        if [ -f "$INSTALL_DIR/client.pid" ]; then
            local pid=$(cat "$INSTALL_DIR/client.pid")
            if kill -0 "$pid" 2>/dev/null; then
                print_info "客户端启动成功 (PID: $pid)"
                log_message "INFO" "客户端启动成功 (PID: $pid)"
                return 0
            fi
        fi
    fi
    
    print_warn "客户端可能未正常启动，请检查日志"
    log_message "WARN" "客户端启动状态未知"
    return 1
}

# 重启客户端
restart_client() {
    print_step "正在重启客户端..."
    
    stop_client
    sleep 1
    start_client
}

# 检查客户端状态
check_client_status() {
    print_step "检查客户端状态..."
    
    if [ -f "$INSTALL_DIR/client.pid" ]; then
        local pid=$(cat "$INSTALL_DIR/client.pid")
        if kill -0 "$pid" 2>/dev/null; then
            print_info "客户端运行中 (PID: $pid)"
            log_message "INFO" "客户端运行中 (PID: $pid)"
            return 0
        else
            print_warn "客户端未运行 (PID 文件存在但进程不存在)"
            log_message "WARN" "客户端未运行"
            return 1
        fi
    else
        print_info "客户端未运行 (无 PID 文件)"
        log_message "INFO" "客户端未运行"
        return 1
    fi
}

# ============================================================================
# 回滚函数
# ============================================================================

# 回滚到备份
rollback() {
    local backup_path=$1
    
    print_step "正在回滚到备份..."
    log_message "INFO" "开始回滚: $backup_path"
    
    if [ ! -d "$backup_path" ]; then
        print_error "备份目录不存在: $backup_path"
        log_message "ERROR" "备份目录不存在: $backup_path"
        return 1
    fi
    
    # 停止客户端
    stop_client
    
    # 恢复文件
    local restore_count=0
    
    for file in $UPDATE_FILES; do
        if [ -f "$backup_path/$file" ]; then
            local dest_dir=$(dirname "$INSTALL_DIR/$file")
            mkdir -p "$dest_dir"
            cp "$backup_path/$file" "$INSTALL_DIR/$file"
            restore_count=$((restore_count + 1))
            print_debug "已恢复: $file"
        fi
    done
    
    # 恢复管理脚本
    for script in start.sh stop.sh status.sh; do
        if [ -f "$backup_path/$script" ]; then
            cp "$backup_path/$script" "$INSTALL_DIR/$script"
            chmod +x "$INSTALL_DIR/$script"
            restore_count=$((restore_count + 1))
        fi
    done
    
    print_info "回滚完成: $restore_count 个文件已恢复"
    log_message "INFO" "回滚完成: $restore_count 个文件已恢复"
    
    # 重启客户端
    start_client
    
    return 0
}

# ============================================================================
# 摘要函数
# ============================================================================

# 显示更新摘要
show_summary() {
    local current_ver=$(get_current_version)
    
    echo ""
    echo -e "${GREEN}========================================${NC}"
    echo -e "${GREEN}  更新完成！${NC}"
    echo -e "${GREEN}========================================${NC}"
    echo ""
    echo "您的配置、证书和日志未被修改。"
    echo ""
    echo -e "${BLUE}当前版本:${NC} $current_ver"
    echo ""
    echo -e "${BLUE}查看日志:${NC}"
    echo "   tail -f $UPDATE_LOG"
    echo ""
    echo -e "${BLUE}客户端状态:${NC}"
    echo "   $INSTALL_DIR/status.sh"
    echo ""
    echo -e "${BLUE}管理命令:${NC}"
    echo "   $INSTALL_DIR/start.sh   - 启动客户端"
    echo "   $INSTALL_DIR/stop.sh    - 停止客户端"
    echo "   $INSTALL_DIR/status.sh  - 查看状态"
    echo ""
}

# 显示帮助信息
show_help() {
    cat << EOF
SMTP 隧道代理 - 客户端更新脚本

用法: $(basename "$0") [选项]

选项:
  --check-only       仅检查版本，不执行更新
  --no-restart      更新后不重启客户端
  --no-backup       不创建备份（不推荐）
  --force           强制更新，即使版本相同
  --debug           启用调试模式
  -h, --help        显示此帮助信息

环境变量:
  DEBUG_MODE        启用调试模式 (true/false)

示例:
  $(basename "$0")                    # 正常更新
  $(basename "$0") --check-only       # 仅检查版本
  $(basename "$0") --no-restart       # 更新但不重启
  $(basename "$0") --force            # 强制更新
  DEBUG_MODE=true $(basename "$0")    # 调试模式

注意:
  - 更新前会自动创建备份
  - 更新失败时会自动回滚
  - 所有操作都会记录到日志文件
  - 配置、证书和日志不会被修改

EOF
}

# ============================================================================
# 主函数
# ============================================================================

main() {
    local check_only=false
    local no_restart=false
    local no_backup=false
    local force=false
    
    # 解析命令行参数
    while [[ $# -gt 0 ]]; do
        case $1 in
            --check-only)
                check_only=true
                shift
                ;;
            --no-restart)
                no_restart=true
                shift
                ;;
            --no-backup)
                no_backup=true
                shift
                ;;
            --force)
                force=true
                shift
                ;;
            --debug)
                DEBUG_MODE=true
                shift
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            *)
                print_error "未知选项: $1"
                show_help
                exit 1
                ;;
        esac
    done
    
    # 显示标题
    echo ""
    echo -e "${GREEN}========================================${NC}"
    echo -e "${GREEN}  SMTP 隧道客户端更新${NC}"
    echo -e "${GREEN}========================================${NC}"
    echo ""
    
    # 检查安装
    if ! check_installation; then
        exit 1
    fi
    
    # 检查日志目录
    check_log_directory
    
    # 检查备份目录
    check_backup_directory
    
    # 记录更新开始
    log_update_start
    
    # 检查网络连接
    if ! check_network; then
        log_update_failure "网络连接失败"
        exit 1
    fi
    
    # 显示版本信息
    show_version_info
    
    # 检查版本
    if [ "$check_only" = true ]; then
        print_info "仅检查版本模式，退出"
        log_update_end
        exit 0
    fi
    
    # 比较版本
    local current_ver=$(get_current_version)
    local latest_ver=$(get_latest_version)
    local version_cmp=$(compare_versions "$current_ver" "$latest_ver")
    
    if [ "$version_cmp" = "same" ] && [ "$force" != true ]; then
        print_info "当前已是最新版本，无需更新"
        log_message "INFO" "当前已是最新版本"
        log_update_end
        exit 0
    fi
    
    # 创建备份
    local backup_path=""
    if [ "$no_backup" != true ]; then
        backup_path=$(create_backup)
        if [ $? -ne 0 ]; then
            log_update_failure "备份创建失败"
            exit 1
        fi
    else
        print_warn "跳过备份创建（不推荐）"
        log_message "WARN" "跳过备份创建"
    fi
    
    # 停止客户端
    stop_client
    
    # 更新文件
    if ! update_files; then
        print_error "文件更新失败"
        
        # 回滚
        if [ -n "$backup_path" ] && [ "$no_backup" != true ]; then
            print_warn "正在回滚..."
            rollback "$backup_path"
        fi
        
        log_update_failure "文件更新失败"
        exit 1
    fi
    
    # 更新管理脚本
    update_management_scripts
    
    # 设置文件权限
    set_permissions
    
    # 更新 Python 包
    update_python_packages
    
    # 清理旧备份
    cleanup_old_backups
    
    # 重启客户端
    if [ "$no_restart" != true ]; then
        restart_client
        check_client_status
    else
        print_info "跳过客户端重启"
        log_message "INFO" "跳过客户端重启"
    fi
    
    # 显示摘要
    show_summary
    
    # 记录更新成功
    log_update_success
    log_update_end
    
    exit 0
}

# 运行主函数
main "$@"
