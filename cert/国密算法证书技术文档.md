# 国密算法证书技术文档

## 文档版本信息

| 版本 | 日期 | 修订内容 | 作者 |
|------|------|----------|------|
| 1.0.0 | 2026-01-18 | 初始版本 | 技术团队 |

---

## 目录

1. [概述](#1-概述)
2. [国密算法技术原理](#2-国密算法技术原理)
   - [2.1 SM2椭圆曲线公钥密码算法](#21-sm2椭圆曲线公钥密码算法)
   - [2.2 SM3密码杂凑算法](#22-sm3密码杂凑算法)
   - [2.3 SM4分组密码算法](#23-sm4分组密码算法)
3. [国密证书结构规范](#3-国密证书结构规范)
4. [密钥生成与管理流程](#4-密钥生成与管理流程)
5. [签名验证机制](#5-签名验证机制)
6. [加密解密流程](#6-加密解密流程)
7. [代码示例](#7-代码示例)
8. [安全注意事项](#8-安全注意事项)
9. [参考文献](#9-参考文献)

---

## 1. 概述

### 1.1 国密算法体系

国密算法是指中国国家密码管理局制定的商用密码算法标准，主要包括：

- **SM2**: 椭圆曲线公钥密码算法，用于数字签名、密钥交换和公钥加密
- **SM3**: 密码杂凑算法，用于数字摘要和消息认证
- **SM4**: 分组密码算法，用于数据加密

### 1.2 国密证书体系

国密证书体系基于X.509证书格式，采用SM2公钥算法和SM3杂凑算法，符合《GM/T 0015-2012 基于SM2密码算法的数字证书格式规范》和《GM/T 0024-2014 SSL VPN技术规范》等国家标准。

### 1.3 应用场景

- 电子政务系统
- 金融支付系统
- 电子商务平台
- 企业内部安全通信
- 网站HTTPS加密

---

## 2. 国密算法技术原理

### 2.1 SM2椭圆曲线公钥密码算法

#### 2.1.1 算法概述

SM2是国家密码管理局发布的椭圆曲线公钥密码算法，基于256位椭圆曲线，提供数字签名、密钥交换和公钥加密功能。SM2算法标准号为**GM/T 0003-2012**。

#### 2.1.2 椭圆曲线参数

SM2推荐使用的椭圆曲线参数如下：

```
椭圆曲线方程: y² = x³ + ax + b (mod p)

参数值:
- p (素数): FFFFFFFE FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF 00000000 FFFFFFFF FFFFFFFF
- a: FFFFFFFE FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF 00000000 FFFFFFFF FFFFFFFC
- b: 28E9FA9E 9D9F5E34 4D5A9E4B CF6509A7 F39789F5 15AB8F92 DDBCBD41 4D940E93
- n (阶): FFFFFFFE FFFFFFFF FFFFFFFF FFFFFFFF 7203DF6B 21C6052B 53BBF409 39D54123
- G (基点): 
  x: 32C4AE2C 1F198119 5F990446 6A39C994 8FE30BBF F2660BE1 715A4589 334C74C7
  y: BC3736A2 F4F6779C 59BDCEE3 6B692153 D0A9877C C62A4740 02DF32E5 2139F0A0
```

#### 2.1.3 密钥对生成

**私钥生成**:
```
1. 选择随机整数 d，满足 1 ≤ d ≤ n-1
2. d 即为私钥
```

**公钥生成**:
```
1. 计算点 P = d × G（椭圆曲线标量乘法）
2. P 即为公钥，表示为 (Px, Py)
```

#### 2.1.4 数字签名算法

**签名过程**:

```
输入: 消息M, 私钥d
输出: 签名(r, s)

步骤:
1. 计算消息摘要 e = SM3(M)
2. 生成随机数 k，满足 1 ≤ k ≤ n-1
3. 计算椭圆曲线点 (x1, y1) = k × G
4. 计算 r = (e + x1) mod n，若 r=0 或 r+k=n，则重新选择k
5. 计算 s = ((1 + d)⁻¹ × (k - r × d)) mod n，若 s=0，则重新选择k
6. 输出签名 (r, s)
```

**验证过程**:

```
输入: 消息M, 签名(r, s), 公钥P
输出: 验证结果（通过/失败）

步骤:
1. 验证 r, s 是否在 [1, n-1] 范围内
2. 计算消息摘要 e = SM3(M)
3. 计算 t = (r + s) mod n，若 t=0，验证失败
4. 计算点 (x1, y1) = s × G + t × P
5. 计算 R = (e + x1) mod n
6. 验证 R 是否等于 r
```

#### 2.1.5 密钥交换算法

**用户A发送给用户B**:

```
1. 生成随机数 rA，计算 RA = rA × G
2. 计算 x1 = RA.x mod n
3. 计算 tA = (dA + x1 × rA) mod n
4. 发送 RA 给用户B
```

**用户B发送给用户A**:

```
1. 生成随机数 rB，计算 RB = rB × G
2. 计算 x2 = RB.x mod n
3. 计算 tB = (dB + x2 × rB) mod n
4. 发送 RB 给用户A
```

**双方计算共享密钥**:

```
用户A计算:
- x2 = RB.x mod n
- U = (h × tB) × (dA × RB + rA × RB)
- K = KDF(x2 || U || y2 || RA.x || RA.y, klen)

用户B计算:
- x1 = RA.x mod n
- V = (h × tA) × (dB × RA + rB × RA)
- K = KDF(x1 || V || y1 || RB.x || RB.y, klen)
```

#### 2.1.6 公钥加密算法

**加密过程**:

```
输入: 明文M, 公钥P
输出: 密文(C1, C2, C3)

步骤:
1. 生成随机数 k，满足 1 ≤ k ≤ n-1
2. 计算椭圆曲线点 C1 = k × G
3. 计算共享点 S = k × P = (x2, y2)
4. 计算 t = KDF(x2 || y2, klen)，若 t为全0，则重新选择k
5. 计算 C2 = M ⊕ t（异或运算）
6. 计算 C3 = SM3(x2 || M || y2)
7. 输出密文 C1 || C2 || C3
```

**解密过程**:

```
输入: 密文(C1, C2, C3), 私钥d
输出: 明文M

步骤:
1. 计算 S = d × C1 = (x2, y2)
2. 计算 t = KDF(x2 || y2, klen)，若 t为全0，解密失败
3. 计算 M' = C2 ⊕ t
4. 计算 u = SM3(x2 || M' || y2)
5. 验证 u 是否等于 C3
6. 若相等，输出 M'，否则解密失败
```

---

### 2.2 SM3密码杂凑算法

#### 2.2.1 算法概述

SM3是国家密码管理局发布的密码杂凑算法，输出256位杂凑值。SM3算法标准号为**GM/T 0004-2012**。

#### 2.2.2 算法特点

- 输出长度: 256位（32字节）
- 分组长度: 512位（64字节）
- 压缩函数轮数: 64轮
- 安全性: 抗碰撞性、抗原像性、抗第二原像性

#### 2.2.3 算法流程

**填充规则**:

```
1. 在消息末尾添加1位"1"
2. 添加k位"0"，使得 (消息长度 + 1 + k) ≡ 448 (mod 512)
3. 添加64位消息长度（大端序）
```

**初始值**:

```
IV[0] = 7380166f 4914b2b9 172442d7 da8a0600
IV[1] = a96f30bc 163138aa e38dee4d b0fb0e4e
IV[2] = 0e8a6f3b 8c8f8c6d 5a1a5d5b 6d3d4a6f
IV[3] = 7a6a5d5b 8c8f8c6d 5a1a5d5b 6d3d4a6f
IV[4] = 5a1a5d5b 6d3d4a6f 7a6a5d5b 8c8f8c6d
IV[5] = 6d3d4a6f 7a6a5d5b 8c8f8c6d 5a1a5d5b
IV[6] = 8c8f8c6d 5a1a5d5b 6d3d4a6f 7a6a5d5b
IV[7] = 5a1a5d5b 6d3d4a6f 7a6a5d5b 8c8f8c6d
```

**压缩函数**:

```
对于每个512位消息分组Wj:
1. 消息扩展: 将16个字扩展为68个字
2. 压缩: 进行64轮迭代运算
3. 更新: 更新8个寄存器值
```

#### 2.2.4 应用场景

- 数字签名（SM2签名中的消息摘要）
- 消息认证码（HMAC-SM3）
- 密钥派生函数（KDF）
- 数据完整性校验

---

### 2.3 SM4分组密码算法

#### 2.3.1 算法概述

SM4是国家密码管理局发布的分组密码算法，分组长度128位，密钥长度128位。SM4算法标准号为**GM/T 0002-2012**。

#### 2.3.2 算法特点

- 分组长度: 128位（16字节）
- 密钥长度: 128位（16字节）
- 轮数: 32轮
- S盒: 8×8置换盒
- 安全性: 抗差分攻击、抗线性攻击

#### 2.3.3 加密流程

**密钥扩展**:

```
输入: 128位密钥MK = (MK0, MK1, MK2, MK3)
输出: 32个轮密钥 RK0, RK1, ..., RK31

步骤:
1. 计算FK = (FK0, FK1, FK2, FK3)
   FK0 = 0xa3b1bac6, FK1 = 0x56aa3350
   FK2 = 0x677d9197, FK3 = 0xb27022dc

2. 计算 K = (K0, K1, K2, K3) = (MK0 ⊕ FK0, MK1 ⊕ FK1, MK2 ⊕ FK2, MK3 ⊕ FK3)

3. 对于 i = 0, 1, ..., 31:
   RKi = Ki
   Ki+4 = Ki ⊕ T'(Ki+1 ⊕ Ki+2 ⊕ Ki+3 ⊕ CKi)
```

**轮函数**:

```
T函数:
1. 非线性变换 τ: 使用S盒进行字节替换
2. 线性变换 L: 循环左移和异或运算

T'(函数):
1. 线性变换 L'
2. 非线性变换 τ
```

**加密过程**:

```
输入: 明文 (X0, X1, X2, X3), 轮密钥 RK0-RK31
输出: 密文 (Y0, Y1, Y2, Y3)

步骤:
对于 i = 0, 1, ..., 31:
  Xi+4 = F(Xi, Xi+1, Xi+2, Xi+3, RKi)
       = Xi ⊕ T(Xi+1 ⊕ Xi+2 ⊕ Xi+3 ⊕ RKi)

反序输出: (Y0, Y1, Y2, Y3) = (X35, X34, X33, X32)
```

#### 2.3.4 解密流程

SM4解密与加密使用相同的算法结构，只是轮密钥使用顺序相反。

```
解密轮密钥: (RK31, RK30, ..., RK0)
```

#### 2.3.5 工作模式

SM4支持多种工作模式：

- **ECB (电子密码本模式)**: 独立加密每个分组
- **CBC (密码分组链接模式)**: 使用前一个密文块加密当前明文块
- **CFB (密码反馈模式)**: 将分组密码转换为流密码
- **OFB (输出反馈模式)**: 生成密钥流
- **CTR (计数器模式)**: 使用计数器生成密钥流
- **GCM (伽罗瓦计数器模式)**: 提供认证加密

#### 2.3.6 应用场景

- 数据存储加密
- 网络传输加密
- 文件加密
- 数据库字段加密

---

## 3. 国密证书结构规范

### 3.1 证书基本结构

国密证书基于X.509 v3格式，采用ASN.1编码。基本结构如下：

```
Certificate ::= SEQUENCE {
    tbsCertificate       TBSCertificate,          -- 证书基本信息
    signatureAlgorithm   AlgorithmIdentifier,     -- 签名算法标识
    signatureValue       BIT STRING               -- 签名值
}
```

### 3.2 TBSCertificate结构

```
TBSCertificate ::= SEQUENCE {
    version         [0]  EXPLICIT Version DEFAULT v1,
    serialNumber         CertificateSerialNumber,
    signature            AlgorithmIdentifier,
    issuer               Name,
    validity             Validity,
    subject              Name,
    subjectPublicKeyInfo SubjectPublicKeyInfo,
    issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,
    subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,
    extensions      [3]  EXPLICIT Extensions OPTIONAL
}
```

### 3.3 国密算法标识

#### 3.3.1 算法OID

国密算法的对象标识符（OID）如下：

```
SM2签名算法:
OID: 1.2.156.10197.1.501
名称: sm2sign

SM2加密算法:
OID: 1.2.156.10197.1.301
名称: sm2encrypt

SM2密钥交换算法:
OID: 1.2.156.10197.1.401
名称: sm2exchange

SM3杂凑算法:
OID: 1.2.156.10197.1.401
名称: sm3

SM4加密算法:
OID: 1.2.156.10197.1.104
名称: sm4
```

#### 3.3.2 签名算法标识

```
AlgorithmIdentifier ::= SEQUENCE {
    algorithm   OBJECT IDENTIFIER,
    parameters  ANY DEFINED BY algorithm OPTIONAL
}
```

SM2签名算法标识示例：

```
AlgorithmIdentifier ::= {
    algorithm: 1.2.156.10197.1.501,  -- SM2签名算法OID
    parameters: NULL
}
```

### 3.4 公钥信息结构

```
SubjectPublicKeyInfo ::= SEQUENCE {
    algorithm           AlgorithmIdentifier,
    subjectPublicKey    BIT STRING
}
```

SM2公钥信息示例：

```
SubjectPublicKeyInfo ::= {
    algorithm: {
        algorithm: 1.2.156.10197.1.301,  -- SM2公钥算法OID
        parameters: {
            namedCurve: 1.2.156.10197.1.301  -- SM2曲线OID
        }
    },
    subjectPublicKey: 04 || X || Y  -- 非压缩格式公钥
}
```

### 3.5 证书扩展字段

国密证书常用的扩展字段：

#### 3.5.1 基本约束

```
BasicConstraints ::= SEQUENCE {
    cA                      BOOLEAN DEFAULT FALSE,
    pathLenConstraint       INTEGER (0..MAX) OPTIONAL
}
```

#### 3.5.2 密钥用途

```
KeyUsage ::= BIT STRING {
    digitalSignature        (0),
    nonRepudiation          (1),
    keyEncipherment         (2),
    dataEncipherment        (3),
    keyAgreement            (4),
    keyCertSign             (5),
    cRLSign                 (6),
    encipherOnly            (7),
    decipherOnly            (8)
}
```

#### 3.5.3 扩展密钥用途

```
ExtKeyUsageSyntax ::= SEQUENCE SIZE (1..MAX) OF KeyPurposeId

KeyPurposeId ::= OBJECT IDENTIFIER

常用扩展密钥用途:
- 1.3.6.1.5.5.7.3.1: 服务器认证
- 1.3.6.1.5.5.7.3.2: 客户端认证
- 1.3.6.1.5.5.7.3.4: 电子邮件保护
- 1.3.6.1.5.5.7.3.8: 时间戳
```

#### 3.5.4 主题备用名称

```
SubjectAltName ::= GeneralNames

GeneralNames ::= SEQUENCE SIZE (1..MAX) OF GeneralName

GeneralName ::= CHOICE {
    otherName                       [0]     OtherName,
    rfc822Name                      [1]     IA5String,
    dNSName                         [2]     IA5String,
    x400Address                     [3]     ORAddress,
    directoryName                   [4]     Name,
    ediPartyName                    [5]     EDIPartyName,
    uniformResourceIdentifier       [6]     IA5String,
    iPAddress                       [7]     OCTET STRING,
    registeredID                    [8]     OBJECT IDENTIFIER
}
```

#### 3.5.5 CRL分发点

```
CRLDistributionPoints ::= SEQUENCE SIZE (1..MAX) OF DistributionPoint

DistributionPoint ::= SEQUENCE {
    distributionPoint       [0] DistributionPointName OPTIONAL,
    reasons                 [1] ReasonFlags OPTIONAL,
    cRLIssuer               [2] GeneralNames OPTIONAL
}
```

#### 3.5.6 证书策略

```
CertificatePolicies ::= SEQUENCE SIZE (1..MAX) OF PolicyInformation

PolicyInformation ::= SEQUENCE {
    policyIdentifier   CertPolicyId,
    policyQualifiers   SEQUENCE SIZE (1..MAX) OF
                        PolicyQualifierInfo OPTIONAL
}
```

### 3.6 证书链结构

```
根证书 (Root CA)
    ↓
中间证书 (Intermediate CA)
    ↓
终端实体证书 (End-Entity Certificate)
```

证书链验证流程：

```
1. 验证终端证书的签名是否由中间证书的公钥验证通过
2. 验证中间证书的签名是否由根证书的公钥验证通过
3. 验证根证书是否为信任锚点
4. 验证证书的有效期、吊销状态等
5. 验证证书路径上的名称约束、策略约束等
```

---

## 4. 密钥生成与管理流程

### 4.1 密钥生成流程

#### 4.1.1 SM2密钥对生成

**步骤1: 生成私钥**

```python
# 生成随机数作为私钥
import os

def generate_sm2_private_key():
    """
    生成SM2私钥
    返回: 私钥d (整数)
    """
    # SM2曲线阶数n
    n = 0xFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123
    
    # 生成随机数d，满足 1 ≤ d ≤ n-1
    while True:
        d = int.from_bytes(os.urandom(32), 'big')
        if 1 <= d < n:
            return d
```

**步骤2: 计算公钥**

```python
def generate_sm2_public_key(private_key, curve_params):
    """
    根据私钥计算SM2公钥
    参数:
        private_key: 私钥d
        curve_params: 椭圆曲线参数
    返回: 公钥点 (x, y)
    """
    # 计算公钥点 P = d × G
    public_point = scalar_multiply(private_key, curve_params.G)
    return public_point
```

#### 4.1.2 密钥格式

**PEM格式私钥**:

```
-----BEGIN EC PRIVATE KEY-----
MHcCAQEEIP+8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8
oAoGCCqBHM9VAYIToUQDQgAE8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8v
K8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK
8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK
8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK
8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK
8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK
8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK
8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK
8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK
-----END EC PRIVATE KEY-----
```

**PEM格式公钥**:

```
-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoEcz1UBgi0DQgAE8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8v
K8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK
8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK
8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK
8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK
8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK
8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK
8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK
8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK8vK
-----END PUBLIC KEY-----
```

### 4.2 密钥存储管理

#### 4.2.1 密钥存储要求

- **硬件安全模块(HSM)**: 用于存储根CA私钥
- **加密存储**: 私钥必须加密存储，使用SM4加密
- **访问控制**: 严格限制私钥访问权限
- **密钥分离**: 不同用途的密钥应分开存储
- **备份策略**: 定期备份密钥，并采用离线存储

#### 4.2.2 密钥加密存储

```python
from gmssl import sm4, func

def encrypt_private_key(private_key, password):
    """
    使用SM4加密私钥
    参数:
        private_key: 私钥（字节串）
        password: 加密密码
    返回: 加密后的私钥
    """
    # 从密码派生密钥
    key = sm4_key_derivation(password)
    
    # 生成随机IV
    iv = os.urandom(16)
    
    # 使用SM4-CBC模式加密
    cipher = sm4.CryptSM4(key, sm4.SM4_CBC, iv)
    encrypted_key = cipher.crypt(private_key)
    
    # 返回IV和加密后的密钥
    return iv + encrypted_key

def decrypt_private_key(encrypted_key, password):
    """
    使用SM4解密私钥
    参数:
        encrypted_key: 加密的私钥（字节串）
        password: 解密密码
    返回: 解密后的私钥
    """
    # 从密码派生密钥
    key = sm4_key_derivation(password)
    
    # 提取IV
    iv = encrypted_key[:16]
    ciphertext = encrypted_key[16:]
    
    # 使用SM4-CBC模式解密
    cipher = sm4.CryptSM4(key, sm4.SM4_CBC, iv)
    private_key = cipher.decrypt(ciphertext)
    
    return private_key
```

### 4.3 密钥生命周期管理

#### 4.3.1 密钥生命周期

```
密钥生成 → 密钥分发 → 密钥使用 → 密钥轮换 → 密钥销毁
```

#### 4.3.2 密钥轮换策略

- **根CA密钥**: 每5-10年轮换一次
- **中间CA密钥**: 每3-5年轮换一次
- **终端实体密钥**: 每1-2年轮换一次
- **会话密钥**: 每次会话结束后立即销毁

#### 4.3.3 密钥销毁流程

```
1. 停止使用密钥
2. 从所有系统中删除密钥
3. 安全擦除存储介质
4. 更新相关配置
5. 记录销毁日志
```

### 4.4 密钥备份与恢复

#### 4.4.1 密钥备份

```python
import json
from datetime import datetime

def backup_key_pair(private_key, public_key, backup_path):
    """
    备份密钥对
    参数:
        private_key: 私钥
        public_key: 公钥
        backup_path: 备份路径
    """
    backup_data = {
        'timestamp': datetime.now().isoformat(),
        'private_key': private_key.hex(),
        'public_key': public_key.hex(),
        'algorithm': 'SM2'
    }
    
    # 使用SM4加密备份数据
    password = get_backup_password()
    encrypted_data = encrypt_backup_data(backup_data, password)
    
    # 写入备份文件
    with open(backup_path, 'wb') as f:
        f.write(encrypted_data)
```

#### 4.4.2 密钥恢复

```python
def restore_key_pair(backup_path, password):
    """
    从备份恢复密钥对
    参数:
        backup_path: 备份文件路径
        password: 解密密码
    返回: (private_key, public_key)
    """
    # 读取备份文件
    with open(backup_path, 'rb') as f:
        encrypted_data = f.read()
    
    # 解密备份数据
    backup_data = decrypt_backup_data(encrypted_data, password)
    
    # 提取密钥对
    private_key = bytes.fromhex(backup_data['private_key'])
    public_key = bytes.fromhex(backup_data['public_key'])
    
    return private_key, public_key
```

---

## 5. 签名验证机制

### 5.1 SM2数字签名

#### 5.1.1 签名生成流程

```mermaid
flowchart TD
    Start([开始])
    Input1[输入: 消息M, 私钥d]
    Step1[计算消息摘要: e = SM3 M]
    Step2[生成随机数: k ∈ 1, n-1]
    Step3[计算椭圆曲线点: x1, y1 = k × G]
    Step4[计算: r = e + x1 mod n]
    Step5{r=0 或 r+k=n?}
    Step6[重新选择k]
    Step7[计算: s = 1+d⁻¹ × k-r×d mod n]
    Step8{s=0?}
    Step9[重新选择k]
    Output[输出: 签名r, s]
    End([结束])

    Start --> Input1
    Input1 --> Step1
    Step1 --> Step2
    Step2 --> Step3
    Step3 --> Step4
    Step4 --> Step5
    Step5 -->|是| Step6
    Step6 --> Step2
    Step5 -->|否| Step7
    Step7 --> Step8
    Step8 -->|是| Step9
    Step9 --> Step2
    Step8 -->|否| Output
    Output --> End

    style Start fill:#e9ecef,stroke:#495057,stroke-width:2px
    style End fill:#e9ecef,stroke:#495057,stroke-width:2px
    style Input1 fill:#d4edda,stroke:#28a745,stroke-width:2px
    style Step1 fill:#d1ecf1,stroke:#17a2b8,stroke-width:2px
    style Step2 fill:#d1ecf1,stroke:#17a2b8,stroke-width:2px
    style Step3 fill:#d1ecf1,stroke:#17a2b8,stroke-width:2px
    style Step4 fill:#d1ecf1,stroke:#17a2b8,stroke-width:2px
    style Step5 fill:#fff3cd,stroke:#ffc107,stroke-width:2px
    style Step6 fill:#f8d7da,stroke:#dc3545,stroke-width:2px
    style Step7 fill:#d1ecf1,stroke:#17a2b8,stroke-width:2px
    style Step8 fill:#fff3cd,stroke:#ffc107,stroke-width:2px
    style Step9 fill:#f8d7da,stroke:#dc3545,stroke-width:2px
    style Output fill:#d4edda,stroke:#28a745,stroke-width:2px
```

#### 5.1.2 签名验证流程

```mermaid
flowchart TD
    Start([开始])
    Input1[输入: 消息M, 签名r,s, 公钥P]
    Step1[验证: 1 ≤ r,s ≤ n-1]
    Step2[计算消息摘要: e = SM3 M]
    Step3[计算: t = r + s mod n]
    Step4{t=0?}
    Fail1[验证失败]
    Step5[计算点: x1, y1 = s×G + t×P]
    Step6[计算: R = e + x1 mod n]
    Step7{R == r?}
    Success[验证结果: 通过]
    Fail2[验证结果: 失败]
    End([结束])

    Start --> Input1
    Input1 --> Step1
    Step1 --> Step2
    Step2 --> Step3
    Step3 --> Step4
    Step4 -->|是| Fail1
    Fail1 --> End
    Step4 -->|否| Step5
    Step5 --> Step6
    Step6 --> Step7
    Step7 -->|是| Success
    Step7 -->|否| Fail2
    Success --> End
    Fail2 --> End

    style Start fill:#e9ecef,stroke:#495057,stroke-width:2px
    style End fill:#e9ecef,stroke:#495057,stroke-width:2px
    style Input1 fill:#d4edda,stroke:#28a745,stroke-width:2px
    style Step1 fill:#d1ecf1,stroke:#17a2b8,stroke-width:2px
    style Step2 fill:#d1ecf1,stroke:#17a2b8,stroke-width:2px
    style Step3 fill:#d1ecf1,stroke:#17a2b8,stroke-width:2px
    style Step4 fill:#fff3cd,stroke:#ffc107,stroke-width:2px
    style Fail1 fill:#f8d7da,stroke:#dc3545,stroke-width:2px
    style Step5 fill:#d1ecf1,stroke:#17a2b8,stroke-width:2px
    style Step6 fill:#d1ecf1,stroke:#17a2b8,stroke-width:2px
    style Step7 fill:#fff3cd,stroke:#ffc107,stroke-width:2px
    style Success fill:#d4edda,stroke:#28a745,stroke-width:2px
    style Fail2 fill:#f8d7da,stroke:#dc3545,stroke-width:2px
```

### 5.2 签名应用场景

#### 5.2.1 证书签名

CA机构使用私钥对证书进行签名：

```python
def sign_certificate(tbs_certificate, ca_private_key):
    """
    对证书进行签名
    参数:
        tbs_certificate: 待签名的证书数据
        ca_private_key: CA私钥
    返回: 签名值
    """
    # 1. 计算证书摘要
    cert_digest = sm3.sm3_hash(func.bytes_to_list(tbs_certificate))
    
    # 2. 使用SM2签名
    signature = sm2_sign(ca_private_key, cert_digest)
    
    return signature
```

#### 5.2.2 消息签名

```python
def sign_message(message, private_key):
    """
    对消息进行签名
    参数:
        message: 待签名的消息
        private_key: 签名私钥
    返回: 签名(r, s)
    """
    # 1. 计算消息摘要
    message_digest = sm3.sm3_hash(func.bytes_to_list(message))
    
    # 2. 使用SM2签名
    signature = sm2_sign(private_key, message_digest)
    
    return signature

def verify_message(message, signature, public_key):
    """
    验证消息签名
    参数:
        message: 原始消息
        signature: 签名(r, s)
        public_key: 验证公钥
    返回: 验证结果（True/False）
    """
    # 1. 计算消息摘要
    message_digest = sm3.sm3_hash(func.bytes_to_list(message))
    
    # 2. 使用SM2验证
    result = sm2_verify(public_key, message_digest, signature)
    
    return result
```

### 5.3 证书签名验证

#### 5.3.1 证书链验证

```python
def verify_certificate_chain(cert_chain, root_cert):
    """
    验证证书链
    参数:
        cert_chain: 证书链 [终端证书, 中间证书1, 中间证书2, ...]
        root_cert: 根证书
    返回: 验证结果
    """
    # 验证根证书
    if not verify_root_certificate(root_cert):
        return False
    
    # 验证中间证书和终端证书
    for i in range(len(cert_chain)):
        if i == 0:
            # 终端证书由第一个中间证书签名
            issuer_cert = cert_chain[i + 1] if len(cert_chain) > 1 else root_cert
        else:
            # 中间证书由下一个证书或根证书签名
            issuer_cert = cert_chain[i + 1] if i + 1 < len(cert_chain) else root_cert
        
        if not verify_certificate_signature(cert_chain[i], issuer_cert):
            return False
    
    return True

def verify_certificate_signature(cert, issuer_cert):
    """
    验证证书签名
    参数:
        cert: 待验证的证书
        issuer_cert: 颁发者证书
    返回: 验证结果
    """
    # 1. 提取证书的签名值
    signature = cert.signature_value
    
    # 2. 提取TBS证书数据
    tbs_data = cert.tbs_certificate
    
    # 3. 计算TBS证书摘要
    tbs_digest = sm3.sm3_hash(func.bytes_to_list(tbs_data))
    
    # 4. 使用颁发者公钥验证签名
    issuer_public_key = issuer_cert.subject_public_key_info
    result = sm2_verify(issuer_public_key, tbs_digest, signature)
    
    return result
```

#### 5.3.2 证书有效期验证

```python
from datetime import datetime

def verify_certificate_validity(cert):
    """
    验证证书有效期
    参数:
        cert: 证书对象
    返回: 验证结果
    """
    now = datetime.utcnow()
    
    # 检查证书是否已生效
    if now < cert.not_before:
        return False
    
    # 检查证书是否已过期
    if now > cert.not_after:
        return False
    
    return True
```

#### 5.3.3 证书吊销验证

```python
def verify_certificate_revocation(cert, crl):
    """
    验证证书是否被吊销
    参数:
        cert: 证书对象
        crl: 证书吊销列表
    返回: 验证结果（True表示未被吊销）
    """
    # 检查证书序列号是否在CRL中
    for revoked_cert in crl.revoked_certificates:
        if revoked_cert.serial_number == cert.serial_number:
            return False
    
    return True
```

---

## 6. 加密解密流程

### 6.1 SM2公钥加密

#### 6.1.1 加密流程

```mermaid
flowchart TD
    Start([开始])
    Input1[输入: 明文M, 公钥P]
    Step1[生成随机数: k ∈ 1, n-1]
    Step2[计算点: C1 = k × G]
    Step3[计算共享点: S = k × P = x2, y2]
    Step4[密钥派生: t = KDFx2 || y2, klen]
    Step5{t 为全0?}
    Step6[重新选择k]
    Step7[计算: C2 = M ⊕ t]
    Step8[计算: C3 = SM3x2 || M || y2]
    Output[输出: 密文 C = C1 || C2 || C3]
    End([结束])

    Start --> Input1
    Input1 --> Step1
    Step1 --> Step2
    Step2 --> Step3
    Step3 --> Step4
    Step4 --> Step5
    Step5 -->|是| Step6
    Step6 --> Step1
    Step5 -->|否| Step7
    Step7 --> Step8
    Step8 --> Output
    Output --> End

    style Start fill:#e9ecef,stroke:#495057,stroke-width:2px
    style End fill:#e9ecef,stroke:#495057,stroke-width:2px
    style Input1 fill:#d4edda,stroke:#28a745,stroke-width:2px
    style Step1 fill:#d1ecf1,stroke:#17a2b8,stroke-width:2px
    style Step2 fill:#d1ecf1,stroke:#17a2b8,stroke-width:2px
    style Step3 fill:#d1ecf1,stroke:#17a2b8,stroke-width:2px
    style Step4 fill:#d1ecf1,stroke:#17a2b8,stroke-width:2px
    style Step5 fill:#fff3cd,stroke:#ffc107,stroke-width:2px
    style Step6 fill:#f8d7da,stroke:#dc3545,stroke-width:2px
    style Step7 fill:#d1ecf1,stroke:#17a2b8,stroke-width:2px
    style Step8 fill:#d1ecf1,stroke:#17a2b8,stroke-width:2px
    style Output fill:#d4edda,stroke:#28a745,stroke-width:2px
```

#### 6.1.2 解密流程

```mermaid
flowchart TD
    Start([开始])
    Input1[输入: 密文C = C1 || C2 || C3, 私钥d]
    Step1[计算点: S = d × C1 = x2, y2]
    Step2[密钥派生: t = KDFx2 || y2, klen]
    Step3{t 为全0?}
    Fail1[解密失败]
    Step4[计算: M' = C2 ⊕ t]
    Step5[计算: u = SM3x2 || M' || y2]
    Step6{u == C3?}
    Success[输出明文 M']
    Fail2[解密失败]
    End([结束])

    Start --> Input1
    Input1 --> Step1
    Step1 --> Step2
    Step2 --> Step3
    Step3 -->|是| Fail1
    Fail1 --> End
    Step3 -->|否| Step4
    Step4 --> Step5
    Step5 --> Step6
    Step6 -->|是| Success
    Step6 -->|否| Fail2
    Success --> End
    Fail2 --> End

    style Start fill:#e9ecef,stroke:#495057,stroke-width:2px
    style End fill:#e9ecef,stroke:#495057,stroke-width:2px
    style Input1 fill:#d4edda,stroke:#28a745,stroke-width:2px
    style Step1 fill:#d1ecf1,stroke:#17a2b8,stroke-width:2px
    style Step2 fill:#d1ecf1,stroke:#17a2b8,stroke-width:2px
    style Step3 fill:#fff3cd,stroke:#ffc107,stroke-width:2px
    style Fail1 fill:#f8d7da,stroke:#dc3545,stroke-width:2px
    style Step4 fill:#d1ecf1,stroke:#17a2b8,stroke-width:2px
    style Step5 fill:#d1ecf1,stroke:#17a2b8,stroke-width:2px
    style Step6 fill:#fff3cd,stroke:#ffc107,stroke-width:2px
    style Success fill:#d4edda,stroke:#28a745,stroke-width:2px
    style Fail2 fill:#f8d7da,stroke:#dc3545,stroke-width:2px
```

### 6.2 SM4对称加密

#### 6.2.1 SM4-CBC模式

```python
from gmssl import sm4, func

def sm4_cbc_encrypt(plaintext, key, iv=None):
    """
    SM4-CBC模式加密
    参数:
        plaintext: 明文（字节串）
        key: 加密密钥（16字节）
        iv: 初始化向量（16字节，若为None则随机生成）
    返回: (iv, ciphertext)
    """
    if iv is None:
        iv = os.urandom(16)
    
    # 填充明文
    padded_plaintext = pkcs7_pad(plaintext, 16)
    
    # 创建加密器
    crypt_sm4 = sm4.CryptSM4(key, sm4.SM4_CBC, iv)
    
    # 加密
    ciphertext = crypt_sm4.crypt(padded_plaintext)
    
    return iv, ciphertext

def sm4_cbc_decrypt(ciphertext, key, iv):
    """
    SM4-CBC模式解密
    参数:
        ciphertext: 密文（字节串）
        key: 解密密钥（16字节）
        iv: 初始化向量（16字节）
    返回: 明文
    """
    # 创建解密器
    crypt_sm4 = sm4.CryptSM4(key, sm4.SM4_CBC, iv)
    
    # 解密
    padded_plaintext = crypt_sm4.decrypt(ciphertext)
    
    # 去除填充
    plaintext = pkcs7_unpad(padded_plaintext, 16)
    
    return plaintext
```

#### 6.2.2 SM4-GCM模式

```python
def sm4_gcm_encrypt(plaintext, key, aad=None):
    """
    SM4-GCM模式加密
    参数:
        plaintext: 明文（字节串）
        key: 加密密钥（16字节）
        aad: 附加认证数据（可选）
    返回: (nonce, ciphertext, tag)
    """
    # 生成随机nonce
    nonce = os.urandom(12)
    
    # 创建加密器
    cipher = sm4_gcm.Cipher(key, nonce)
    
    # 加密并生成认证标签
    ciphertext, tag = cipher.encrypt_and_digest(plaintext, aad)
    
    return nonce, ciphertext, tag

def sm4_gcm_decrypt(ciphertext, key, nonce, tag, aad=None):
    """
    SM4-GCM模式解密
    参数:
        ciphertext: 密文（字节串）
        key: 解密密钥（16字节）
        nonce: nonce（12字节）
        tag: 认证标签（16字节）
        aad: 附加认证数据（可选）
    返回: 明文
    """
    # 创建解密器
    cipher = sm4_gcm.Cipher(key, nonce)
    
    # 解密并验证
    plaintext = cipher.decrypt_and_verify(ciphertext, tag, aad)
    
    return plaintext
```

### 6.3 密钥派生函数

#### 6.3.1 KDF函数

```python
def kdf_sm3(z, klen):
    """
    基于SM3的密钥派生函数
    参数:
        z: 输入数据（字节串）
        klen: 输出密钥长度（比特）
    返回: 派生密钥（字节串）
    """
    # 计算需要的哈希次数
    ct = 1
    v = 256  # SM3输出长度（比特）
    
    if klen % v != 0:
        ct = klen // v + 1
    else:
        ct = klen // v
    
    # 派生密钥
    k = b''
    for i in range(1, ct + 1):
        # 计算哈希: SM3(z || ct)
        ha = sm3.sm3_hash(func.bytes_to_list(z + i.to_bytes(4, 'big')))
        k += bytes.fromhex(ha)
    
    # 截取所需长度的密钥
    return k[:klen // 8]
```

#### 6.3.2 密钥派生应用

```python
def derive_session_key(private_key, peer_public_key):
    """
    使用ECDH派生会话密钥
    参数:
        private_key: 本地私钥
        peer_public_key: 对方公钥
    返回: 会话密钥
    """
    # 计算共享密钥
    shared_point = scalar_multiply(private_key, peer_public_key)
    
    # 使用KDF派生会话密钥
    session_key = kdf_sm3(shared_point.x.to_bytes(32, 'big') + 
                         shared_point.y.to_bytes(32, 'big'), 256)
    
    return session_key
```

### 6.4 混合加密方案

#### 6.4.1 加密流程

```python
def hybrid_encrypt(plaintext, recipient_public_key):
    """
    混合加密方案（SM2 + SM4）
    参数:
        plaintext: 明文
        recipient_public_key: 接收方SM2公钥
    返回: 加密数据
    """
    # 1. 生成随机SM4密钥
    sm4_key = os.urandom(16)
    sm4_iv = os.urandom(16)
    
    # 2. 使用SM4加密明文
    _, sm4_ciphertext = sm4_cbc_encrypt(plaintext, sm4_key, sm4_iv)
    
    # 3. 使用SM2加密SM4密钥
    encrypted_key = sm2_encrypt(sm4_key + sm4_iv, recipient_public_key)
    
    # 4. 组合加密数据
    encrypted_data = {
        'encrypted_key': encrypted_key,
        'ciphertext': sm4_ciphertext.hex()
    }
    
    return encrypted_data
```

#### 6.4.2 解密流程

```python
def hybrid_decrypt(encrypted_data, recipient_private_key):
    """
    混合解密方案
    参数:
        encrypted_data: 加密数据
        recipient_private_key: 接收方SM2私钥
    返回: 明文
    """
    # 1. 使用SM2解密SM4密钥
    key_and_iv = sm2_decrypt(encrypted_data['encrypted_key'], recipient_private_key)
    sm4_key = key_and_iv[:16]
    sm4_iv = key_and_iv[16:]
    
    # 2. 使用SM4解密密文
    ciphertext = bytes.fromhex(encrypted_data['ciphertext'])
    plaintext = sm4_cbc_decrypt(ciphertext, sm4_key, sm4_iv)
    
    return plaintext
```

---

## 7. 代码示例

### 7.1 证书生成示例

```python
from gmssl import sm2, func
from datetime import datetime, timedelta
import asn1crypto.x509
from asn1crypto.keys import PublicKeyInfo
from asn1crypto.core import Sequence, Integer, BitString

class SM2CertificateGenerator:
    """
    SM2证书生成器
    """
    
    def __init__(self):
        # 初始化SM2对象
        self.sm2_crypt = sm2.CryptSM2(
            private_key='',
            public_key=''
        )
    
    def generate_key_pair(self):
        """
        生成SM2密钥对
        返回: (private_key, public_key)
        """
        # 生成私钥
        private_key = self.sm2_crypt.private_key_generate()
        
        # 计算公钥
        public_key = self.sm2_crypt.public_key_generate(private_key)
        
        return private_key, public_key
    
    def create_certificate(self, subject_name, issuer_name, 
                          public_key, issuer_private_key,
                          validity_days=365):
        """
        创建证书
        参数:
            subject_name: 主体名称
            issuer_name: 颁发者名称
            public_key: 主体公钥
            issuer_private_key: 颁发者私钥
            validity_days: 有效期（天）
        返回: 证书（PEM格式）
        """
        # 生成证书序列号
        serial_number = self._generate_serial_number()
        
        # 设置证书有效期
        not_before = datetime.utcnow()
        not_after = not_before + timedelta(days=validity_days)
        
        # 构建TBS证书
        tbs_certificate = self._build_tbs_certificate(
            serial_number=serial_number,
            subject_name=subject_name,
            issuer_name=issuer_name,
            public_key=public_key,
            not_before=not_before,
            not_after=not_after
        )
        
        # 对证书进行签名
        signature = self._sign_certificate(tbs_certificate, issuer_private_key)
        
        # 构建完整证书
        certificate = self._build_certificate(tbs_certificate, signature)
        
        # 转换为PEM格式
        pem_certificate = self._to_pem(certificate)
        
        return pem_certificate
    
    def _generate_serial_number(self):
        """生成证书序列号"""
        import random
        return random.randint(1, 2**64 - 1)
    
    def _build_tbs_certificate(self, serial_number, subject_name, 
                              issuer_name, public_key, 
                              not_before, not_after):
        """构建TBS证书"""
        # 这里简化实现，实际需要使用asn1crypto库构建完整的ASN.1结构
        pass
    
    def _sign_certificate(self, tbs_certificate, private_key):
        """对证书进行签名"""
        # 计算证书摘要
        cert_digest = sm3.sm3_hash(func.bytes_to_list(tbs_certificate))
        
        # 使用SM2签名
        signature = self.sm2_crypt.sign(cert_digest, private_key)
        
        return signature
    
    def _build_certificate(self, tbs_certificate, signature):
        """构建完整证书"""
        # 这里简化实现，实际需要使用asn1crypto库构建完整的ASN.1结构
        pass
    
    def _to_pem(self, certificate):
        """转换为PEM格式"""
        import base64
        
        # Base64编码
        cert_b64 = base64.b64encode(certificate).decode('utf-8')
        
        # 分行（每64字符一行）
        cert_b64_lines = [cert_b64[i:i+64] for i in range(0, len(cert_b64), 64)]
        cert_b64 = '\n'.join(cert_b64_lines)
        
        # 添加PEM头尾
        pem_cert = f"-----BEGIN CERTIFICATE-----\n{cert_b64}\n-----END CERTIFICATE-----"
        
        return pem_cert


# 使用示例
if __name__ == "__main__":
    # 创建证书生成器
    cert_generator = SM2CertificateGenerator()
    
    # 生成CA密钥对
    ca_private_key, ca_public_key = cert_generator.generate_key_pair()
    
    # 生成终端实体密钥对
    ee_private_key, ee_public_key = cert_generator.generate_key_pair()
    
    # 创建CA证书（自签名）
    ca_cert = cert_generator.create_certificate(
        subject_name="CN=Root CA, O=My Organization, C=CN",
        issuer_name="CN=Root CA, O=My Organization, C=CN",
        public_key=ca_public_key,
        issuer_private_key=ca_private_key,
        validity_days=3650
    )
    
    # 创建终端实体证书
    ee_cert = cert_generator.create_certificate(
        subject_name="CN=www.example.com, O=My Organization, C=CN",
        issuer_name="CN=Root CA, O=My Organization, C=CN",
        public_key=ee_public_key,
        issuer_private_key=ca_private_key,
        validity_days=365
    )
    
    print("CA证书:")
    print(ca_cert)
    print("\n终端实体证书:")
    print(ee_cert)
```

### 7.2 签名验证示例

```python
from gmssl import sm2, sm3, func

class SM2Signature:
    """
    SM2签名验证类
    """
    
    def __init__(self):
        self.sm2_crypt = sm2.CryptSM2(
            private_key='',
            public_key=''
        )
    
    def sign(self, message, private_key):
        """
        对消息进行签名
        参数:
            message: 待签名的消息
            private_key: 签名私钥
        返回: 签名(r, s)
        """
        # 计算消息摘要
        message_bytes = message.encode('utf-8') if isinstance(message, str) else message
        message_digest = sm3.sm3_hash(func.bytes_to_list(message_bytes))
        
        # 使用SM2签名
        signature = self.sm2_crypt.sign(message_digest, private_key)
        
        return signature
    
    def verify(self, message, signature, public_key):
        """
        验证消息签名
        参数:
            message: 原始消息
            signature: 签名(r, s)
            public_key: 验证公钥
        返回: 验证结果（True/False）
        """
        # 计算消息摘要
        message_bytes = message.encode('utf-8') if isinstance(message, str) else message
        message_digest = sm3.sm3_hash(func.bytes_to_list(message_bytes))
        
        # 使用SM2验证
        result = self.sm2_crypt.verify(message_digest, signature, public_key)
        
        return result
    
    def sign_file(self, file_path, private_key):
        """
        对文件进行签名
        参数:
            file_path: 文件路径
            private_key: 签名私钥
        返回: 文件签名
        """
        # 读取文件内容
        with open(file_path, 'rb') as f:
            file_content = f.read()
        
        # 对文件内容进行签名
        signature = self.sign(file_content, private_key)
        
        return signature
    
    def verify_file(self, file_path, signature, public_key):
        """
        验证文件签名
        参数:
            file_path: 文件路径
            signature: 文件签名
            public_key: 验证公钥
        返回: 验证结果（True/False）
        """
        # 读取文件内容
        with open(file_path, 'rb') as f:
            file_content = f.read()
        
        # 验证文件签名
        result = self.verify(file_content, signature, public_key)
        
        return result


# 使用示例
if __name__ == "__main__":
    # 创建签名验证对象
    sm2_sig = SM2Signature()
    
    # 生成密钥对
    private_key, public_key = sm2_sig.sm2_crypt.private_key_generate(), \
                             sm2_sig.sm2_crypt.public_key_generate(private_key)
    
    # 待签名的消息
    message = "Hello, SM2 Signature!"
    
    # 签名
    signature = sm2_sig.sign(message, private_key)
    print(f"签名结果: {signature}")
    
    # 验证
    result = sm2_sig.verify(message, signature, public_key)
    print(f"验证结果: {'通过' if result else '失败'}")
    
    # 文件签名示例
    file_path = "test.txt"
    with open(file_path, 'w') as f:
        f.write("This is a test file for SM2 signature.")
    
    # 对文件进行签名
    file_signature = sm2_sig.sign_file(file_path, private_key)
    print(f"\n文件签名: {file_signature}")
    
    # 验证文件签名
    file_result = sm2_sig.verify_file(file_path, file_signature, public_key)
    print(f"文件签名验证结果: {'通过' if file_result else '失败'}")
```

### 7.3 加密解密示例

```python
from gmssl import sm2, sm4, func
import os

class SM2Encryption:
    """
    SM2加密解密类
    """
    
    def __init__(self):
        self.sm2_crypt = sm2.CryptSM2(
            private_key='',
            public_key=''
        )
    
    def encrypt(self, plaintext, public_key):
        """
        使用SM2加密数据
        参数:
            plaintext: 明文
            public_key: 加密公钥
        返回: 密文
        """
        # 将明文转换为字节串
        plaintext_bytes = plaintext.encode('utf-8') if isinstance(plaintext, str) else plaintext
        
        # 使用SM2加密
        ciphertext = self.sm2_crypt.encrypt(plaintext_bytes, public_key)
        
        return ciphertext
    
    def decrypt(self, ciphertext, private_key):
        """
        使用SM2解密数据
        参数:
            ciphertext: 密文
            private_key: 解密私钥
        返回: 明文
        """
        # 使用SM2解密
        plaintext_bytes = self.sm2_crypt.decrypt(ciphertext, private_key)
        
        # 将字节串转换为字符串
        plaintext = plaintext_bytes.decode('utf-8')
        
        return plaintext


class SM4Encryption:
    """
    SM4加密解密类
    """
    
    def __init__(self):
        self.crypt_sm4 = None
    
    def generate_key(self):
        """
        生成SM4密钥
        返回: 16字节密钥
        """
        return os.urandom(16)
    
    def encrypt(self, plaintext, key, iv=None):
        """
        使用SM4-CBC模式加密
        参数:
            plaintext: 明文
            key: 加密密钥（16字节）
            iv: 初始化向量（16字节，若为None则随机生成）
        返回: (iv, ciphertext)
        """
        if iv is None:
            iv = os.urandom(16)
        
        # 填充明文
        plaintext_bytes = plaintext.encode('utf-8') if isinstance(plaintext, str) else plaintext
        padded_plaintext = self._pkcs7_pad(plaintext_bytes, 16)
        
        # 创建加密器
        self.crypt_sm4 = sm4.CryptSM4(key, sm4.SM4_CBC, iv)
        
        # 加密
        ciphertext = self.crypt_sm4.crypt(padded_plaintext)
        
        return iv, ciphertext
    
    def decrypt(self, ciphertext, key, iv):
        """
        使用SM4-CBC模式解密
        参数:
            ciphertext: 密文
            key: 解密密钥（16字节）
            iv: 初始化向量（16字节）
        返回: 明文
        """
        # 创建解密器
        self.crypt_sm4 = sm4.CryptSM4(key, sm4.SM4_CBC, iv)
        
        # 解密
        padded_plaintext = self.crypt_sm4.decrypt(ciphertext)
        
        # 去除填充
        plaintext = self._pkcs7_unpad(padded_plaintext, 16)
        
        # 将字节串转换为字符串
        plaintext_str = plaintext.decode('utf-8')
        
        return plaintext_str
    
    def _pkcs7_pad(self, data, block_size):
        """PKCS7填充"""
        pad_length = block_size - (len(data) % block_size)
        padding = bytes([pad_length] * pad_length)
        return data + padding
    
    def _pkcs7_unpad(self, data, block_size):
        """PKCS7去填充"""
        pad_length = data[-1]
        return data[:-pad_length]


# 使用示例
if __name__ == "__main__":
    # SM2加密示例
    print("=== SM2加密解密示例 ===")
    sm2_enc = SM2Encryption()
    
    # 生成密钥对
    private_key, public_key = sm2_enc.sm2_crypt.private_key_generate(), \
                             sm2_enc.sm2_crypt.public_key_generate(private_key)
    
    # 待加密的消息
    message = "Hello, SM2 Encryption!"
    print(f"原始消息: {message}")
    
    # 加密
    ciphertext = sm2_enc.encrypt(message, public_key)
    print(f"加密后的密文: {ciphertext}")
    
    # 解密
    decrypted_message = sm2_enc.decrypt(ciphertext, private_key)
    print(f"解密后的消息: {decrypted_message}")
    
    # SM4加密示例
    print("\n=== SM4加密解密示例 ===")
    sm4_enc = SM4Encryption()
    
    # 生成密钥
    sm4_key = sm4_enc.generate_key()
    print(f"SM4密钥: {sm4_key.hex()}")
    
    # 待加密的消息
    message = "Hello, SM4 Encryption!"
    print(f"原始消息: {message}")
    
    # 加密
    iv, ciphertext = sm4_enc.encrypt(message, sm4_key)
    print(f"IV: {iv.hex()}")
    print(f"加密后的密文: {ciphertext.hex()}")
    
    # 解密
    decrypted_message = sm4_enc.decrypt(ciphertext, sm4_key, iv)
    print(f"解密后的消息: {decrypted_message}")
```

### 7.4 证书验证示例

```python
from gmssl import sm2, sm3, func
from datetime import datetime

class CertificateValidator:
    """
    证书验证器
    """
    
    def __init__(self):
        self.sm2_crypt = sm2.CryptSM2(
            private_key='',
            public_key=''
        )
    
    def verify_certificate(self, cert, issuer_cert):
        """
        验证证书
        参数:
            cert: 待验证的证书
            issuer_cert: 颁发者证书
        返回: 验证结果（True/False）
        """
        # 1. 验证证书签名
        if not self._verify_signature(cert, issuer_cert):
            return False
        
        # 2. 验证证书有效期
        if not self._verify_validity(cert):
            return False
        
        # 3. 验证证书吊销状态
        if not self._verify_revocation(cert):
            return False
        
        # 4. 验证证书用途
        if not self._verify_key_usage(cert):
            return False
        
        return True
    
    def _verify_signature(self, cert, issuer_cert):
        """
        验证证书签名
        """
        # 提取证书的签名值
        signature = cert['signature_value']
        
        # 提取TBS证书数据
        tbs_data = cert['tbs_certificate']
        
        # 计算TBS证书摘要
        tbs_digest = sm3.sm3_hash(func.bytes_to_list(tbs_data))
        
        # 使用颁发者公钥验证签名
        issuer_public_key = issuer_cert['subject_public_key_info']['subject_public_key']
        result = self.sm2_crypt.verify(tbs_digest, signature, issuer_public_key)
        
        return result
    
    def _verify_validity(self, cert):
        """
        验证证书有效期
        """
        now = datetime.utcnow()
        
        # 检查证书是否已生效
        if now < cert['not_before']:
            return False
        
        # 检查证书是否已过期
        if now > cert['not_after']:
            return False
        
        return True
    
    def _verify_revocation(self, cert):
        """
        验证证书吊销状态
        """
        # 这里简化实现，实际需要查询CRL或OCSP
        return True
    
    def _verify_key_usage(self, cert):
        """
        验证证书用途
        """
        # 这里简化实现，实际需要检查密钥用途扩展
        return True


# 使用示例
if __name__ == "__main__":
    # 创建证书验证器
    cert_validator = CertificateValidator()
    
    # 这里假设已经加载了证书
    # cert = load_certificate("ee_cert.pem")
    # issuer_cert = load_certificate("ca_cert.pem")
    
    # 验证证书
    # result = cert_validator.verify_certificate(cert, issuer_cert)
    # print(f"证书验证结果: {'通过' if result else '失败'}")
    
    print("证书验证示例（需要实际证书数据）")
```

---

## 8. 安全注意事项

### 8.1 密钥安全

#### 8.1.1 密钥生成

- **使用安全的随机数生成器**: 必须使用密码学安全的随机数生成器（CSPRNG）
- **避免弱密钥**: 确保密钥具有足够的熵值
- **密钥长度**: SM2使用256位密钥，SM4使用128位密钥
- **密钥分离**: 不同用途的密钥应分开生成和存储

```python
# 正确的密钥生成示例
import os

def generate_secure_key():
    """
    生成安全的随机密钥
    """
    # 使用os.urandom生成密码学安全的随机数
    key = os.urandom(32)  # 256位密钥
    return key

# 错误的密钥生成示例（不要使用）
import random

def generate_weak_key():
    """
    不安全的密钥生成（不要使用）
    """
    # 使用random模块不安全
    key = bytes([random.randint(0, 255) for _ in range(32)])
    return key
```

#### 8.1.2 密钥存储

- **加密存储**: 私钥必须加密存储
- **访问控制**: 严格限制私钥访问权限
- **硬件安全模块(HSM)**: 根CA私钥应存储在HSM中
- **密钥备份**: 定期备份密钥，并采用离线存储
- **密钥销毁**: 不再使用的密钥应安全销毁

```python
# 密钥加密存储示例
from gmssl import sm4

def encrypt_key_for_storage(private_key, password):
    """
    加密私钥用于存储
    参数:
        private_key: 私钥
        password: 加密密码
    返回: 加密后的私钥
    """
    # 从密码派生密钥
    key = derive_key_from_password(password)
    
    # 生成随机IV
    iv = os.urandom(16)
    
    # 使用SM4加密
    cipher = sm4.CryptSM4(key, sm4.SM4_CBC, iv)
    encrypted_key = cipher.crypt(private_key)
    
    # 返回IV和加密后的密钥
    return iv + encrypted_key
```

### 8.2 随机数安全

#### 8.2.1 随机数生成

- **使用CSPRNG**: 必须使用密码学安全的伪随机数生成器
- **避免重复**: 避免重复使用相同的随机数
- **随机数质量**: 确保随机数具有足够的熵值

```python
# 安全的随机数生成示例
import os

def generate_secure_random(length):
    """
    生成安全的随机数
    参数:
        length: 随机数长度（字节）
    返回: 随机数
    """
    return os.urandom(length)

# SM2签名中使用的随机数k
def generate_sm2_k():
    """
    生成SM2签名随机数k
    """
    # SM2曲线阶数n
    n = 0xFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123
    
    # 生成随机数k，满足 1 ≤ k ≤ n-1
    while True:
        k_bytes = os.urandom(32)
        k = int.from_bytes(k_bytes, 'big')
        if 1 <= k < n:
            return k
```

### 8.3 侧信道攻击防护

#### 8.3.1 时间攻击防护

- **恒定时间算法**: 使用恒定时间算法进行密码运算
- **避免分支**: 避免在密码运算中使用条件分支
- **随机延迟**: 添加随机延迟以混淆时间信息

```python
# 恒定时间比较示例
def constant_time_compare(a, b):
    """
    恒定时间比较
    参数:
        a: 字节串a
        b: 字节串b
    返回: 比较结果（True/False）
    """
    if len(a) != len(b):
        return False
    
    result = 0
    for x, y in zip(a, b):
        result |= x ^ y
    
    return result == 0
```

#### 8.3.2 功耗攻击防护

- **掩码技术**: 使用掩码技术隐藏中间值
- **随机化**: 随机化运算顺序
- **硬件防护**: 使用具有侧信道防护的硬件

### 8.4 实现安全

#### 8.4.1 错误处理

- **安全错误处理**: 避免在错误信息中泄露敏感信息
- **日志记录**: 记录安全相关的错误和事件
- **异常处理**: 正确处理异常情况

```python
# 安全的错误处理示例
def secure_decrypt(ciphertext, private_key):
    """
    安全的解密函数
    """
    try:
        # 解密操作
        plaintext = decrypt(ciphertext, private_key)
        return plaintext
    except Exception as e:
        # 记录错误日志
        log_error(f"Decryption failed: {str(e)}")
        # 返回通用错误信息
        raise DecryptionError("Decryption failed")
```

#### 8.4.2 输入验证

- **输入验证**: 验证所有输入数据
- **长度检查**: 检查输入数据的长度
- **格式验证**: 验证输入数据的格式

```python
# 输入验证示例
def validate_certificate_input(cert_data):
    """
    验证证书输入
    参数:
        cert_data: 证书数据
    返回: 验证结果（True/False）
    """
    # 检查数据长度
    if len(cert_data) > MAX_CERT_SIZE:
        return False
    
    # 检查数据格式
    if not is_valid_cert_format(cert_data):
        return False
    
    return True
```

### 8.5 协议安全

#### 8.5.1 TLS协议

- **使用最新版本**: 使用TLS 1.2或更高版本
- **禁用弱密码套件**: 禁用弱密码套件
- **证书验证**: 严格验证服务器证书
- **前向保密**: 使用支持前向保密的密钥交换算法

#### 8.5.2 密钥交换

- **使用ECDH**: 使用椭圆曲线Diffie-Hellman进行密钥交换
- **临时密钥**: 使用临时密钥进行密钥交换
- **密钥确认**: 实现密钥确认机制

### 8.6 审计与监控

#### 8.6.1 安全审计

- **日志记录**: 记录所有安全相关事件
- **审计追踪**: 维护完整的审计追踪
- **定期审计**: 定期进行安全审计

#### 8.6.2 监控告警

- **异常检测**: 检测异常行为
- **实时监控**: 实时监控系统状态
- **告警机制**: 建立告警机制

### 8.7 合规性要求

#### 8.7.1 国家标准

- **GM/T 0002-2012**: SM4分组密码算法
- **GM/T 0003-2012**: SM2椭圆曲线公钥密码算法
- **GM/T 0004-2012**: SM3密码杂凑算法
- **GM/T 0015-2012**: 基于SM2密码算法的数字证书格式规范
- **GM/T 0024-2014**: SSL VPN技术规范

#### 8.7.2 行业标准

- **金融行业**: 遵循金融行业安全标准
- **电子政务**: 遵循电子政务安全标准
- **电子商务**: 遵循电子商务安全标准

---

## 9. 参考文献

### 9.1 国家标准

1. **GM/T 0002-2012**: SM4分组密码算法
2. **GM/T 0003-2012**: SM2椭圆曲线公钥密码算法
3. **GM/T 0004-2012**: SM3密码杂凑算法
4. **GM/T 0015-2012**: 基于SM2密码算法的数字证书格式规范
5. **GM/T 0024-2014**: SSL VPN技术规范
6. **GM/T 0029-2014**: SM2密码算法使用规范
7. **GM/T 0044-2016**: SM2椭圆曲线公钥密码算法技术规范

### 9.2 国际标准

1. **RFC 5280**: Internet X.509 Public Key Infrastructure Certificate and CRL Profile
2. **RFC 5246**: The Transport Layer Security (TLS) Protocol Version 1.2
3. **RFC 8446**: The Transport Layer Security (TLS) Protocol Version 1.3
4. **ISO/IEC 19772**: Information technology — Security techniques — Authenticated encryption

### 9.3 技术文档

1. **国家密码管理局**: 商用密码管理条例
2. **国家密码管理局**: 商用密码产品管理办法
3. **国家密码管理局**: 电子认证服务密码管理办法

### 9.4 参考书籍

1. 《密码学原理与实践》- Douglas R. Stinson
2. 《椭圆曲线密码学导论》- Darrel Hankerson 等
3. 《应用密码学》- Bruce Schneier

### 9.5 在线资源

1. 国家密码管理局官网: https://www.oscca.gov.cn/
2. GMSSL开源项目: https://github.com/guanzhi/GmSSL
3. OpenSSL国密支持: https://www.openssl.org/

---

## 附录

### 附录A: SM2椭圆曲线参数详细值

```
素数 p:
FFFFFFFE FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF 00000000 FFFFFFFF FFFFFFFF

系数 a:
FFFFFFFE FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF 00000000 FFFFFFFF FFFFFFFC

系数 b:
28E9FA9E 9D9F5E34 4D5A9E4B CF6509A7 F39789F5 15AB8F92 DDBCBD41 4D940E93

基点 G 的 x 坐标:
32C4AE2C 1F198119 5F990446 6A39C994 8FE30BBF F2660BE1 715A4589 334C74C7

基点 G 的 y 坐标:
BC3736A2 F4F6779C 59BDCEE3 6B692153 D0A9877C C62A4740 02DF32E5 2139F0A0

阶 n:
FFFFFFFE FFFFFFFF FFFFFFFF FFFFFFFF 7203DF6B 21C6052B 53BBF409 39D54123

余因子 h:
01
```

### 附录B: SM3初始值

```
IV[0] = 7380166f
IV[1] = 4914b2b9
IV[2] = 172442d7
IV[3] = da8a0600
IV[4] = a96f30bc
IV[5] = 163138aa
IV[6] = e38dee4d
IV[7] = b0fb0e4e
```

### 附录C: SM4 S盒

```
S盒（十六进制）:
d6 90 e9 fe cc e1 3d b7 16 b6 14 c2 28 fb 2c 05
2b 67 9a 76 2a be 04 c3 aa 44 13 26 49 86 06 99
9c 42 50 f4 91 ef 98 7a 33 54 0b 43 ed cf ac 62
e4 b3 1c a9 c9 08 e8 95 80 df 94 fa 75 8f 3f a6
47 07 a7 fc f3 73 17 ba 83 59 3c 19 e6 85 4f a8
68 6b 81 b2 71 64 da 8b f8 eb 0f 4b 70 56 9d 35
1e 24 0e 5e 63 58 d1 a2 25 22 7c 3b 01 21 78 87
d4 00 46 57 9f d3 27 52 4f 36 02 e7 a0 c4 c8 9e
ea bf 8a d2 40 c7 38 b5 a3 f7 f2 ce f9 61 15 a1
e0 ae 5d a4 9b 34 1a 55 ad 93 32 30 f5 8c b1 e3
1d f6 e2 2e 82 66 ca 60 c0 29 23 ab 0d 53 4e 6f
d5 db 37 45 de fd 8e 2f 03 ff 6a 72 6d 6c 5b 51
8d 1b af 92 bb dd bc 7f 11 d9 5c 41 1f 10 5a d8
0a c1 31 88 a5 cd 7b bd 2f 74 d0 12 b8 e5 b4 b0
89 69 97 4a 0c 96 77 7e 65 b9 f1 09 c5 6e c6 84
18 f0 7d ec 3a dc 4d 20 79 ee 5f 3e d7 cb 39 48
```

### 附录D: 常用OID列表

```
SM2签名算法:
1.2.156.10197.1.501

SM2加密算法:
1.2.156.10197.1.301

SM2密钥交换算法:
1.2.156.10197.1.401

SM3杂凑算法:
1.2.156.10197.1.401

SM4加密算法:
1.2.156.10197.1.104

SM2椭圆曲线:
1.2.156.10197.1.301

服务器认证:
1.3.6.1.5.5.7.3.1

客户端认证:
1.3.6.1.5.5.7.3.2

电子邮件保护:
1.3.6.1.5.5.7.3.4

时间戳:
1.3.6.1.5.5.7.3.8
```

---

**文档结束**
