# 单域名证书技术文档

## 目录

1. [引言](#1-引言)
2. [证书基础知识](#2-证书基础知识)
3. [单域名证书概述](#3-单域名证书概述)
4. [证书生成流程](#4-证书生成流程)
5. [证书配置方法](#5-证书配置方法)
6. [证书验证方法](#6-证书验证方法)
7. [证书有效期管理](#7-证书有效期管理)
8. [证书更新机制](#8-证书更新机制)
9. [安全最佳实践](#9-安全最佳实践)
10. [常见问题解决方案](#10-常见问题解决方案)
11. [故障排除指南](#11-故障排除指南)
12. [附录：工具与资源](#12-附录工具与资源)

---

## 1. 引言

### 1.1 文档目的

本文档旨在为技术人员提供单域名证书的完整管理指南，涵盖证书的生成、配置、验证、更新和维护等全生命周期管理。通过本文档，技术人员能够独立完成单域名证书的各项操作，确保 SMTP 隧道代理系统的安全通信。

### 1.2 适用范围

本文档适用于以下场景：
- SMTP 隧道代理服务器的 TLS 证书配置
- 单域名证书的自签名生成和管理
- 证书的部署、验证和维护
- 证书相关的故障排除

### 1.3 目标读者

- 系统管理员
- 网络工程师
- 安全工程师
- DevOps 工程师

### 1.4 前置知识

阅读本文档需要具备以下基础知识：
- 基本的 Linux 命令行操作
- SSL/TLS 协议基础
- 证书和密钥的基本概念
- SMTP 协议基础

---

## 2. 证书基础知识

### 2.1 什么是 SSL/TLS 证书

SSL/TLS 证书是一种数字证书，用于在客户端和服务器之间建立加密通信通道。证书包含以下关键信息：

| 字段 | 说明 | 示例 |
|------|------|------|
| **版本** | 证书版本号 | 3 (X.509 v3) |
| **序列号** | 证书唯一标识符 | 04:AB:CD:EF:12:34:56:78 |
| **签名算法** | 证书签名使用的算法 | sha256WithRSAEncryption |
| **颁发者** | 签发证书的 CA | CN=SMTP Tunnel CA |
| **有效期** | 证书的有效时间范围 | 2023-01-01 至 2026-01-01 |
| **主题** | 证书持有者信息 | CN=mail.example.com |
| **公钥** | 证书的公钥信息 | RSA Public Key: 2048 bit |
| **扩展** | 证书扩展字段 | SAN, Key Usage, EKU |

### 2.2 证书类型对比

| 证书类型 | 验证级别 | 适用场景 | 信任度 | 成本 |
|----------|----------|----------|--------|------|
| **自签名证书** | 无验证 | 内部测试、开发环境 | 低 | 免费 |
| **DV 证书** | 域名验证 | 个人网站、测试环境 | 中 | 免费/低 |
| **OV 证书** | 组织验证 | 企业网站、电商平台 | 高 | 中等 |
| **EV 证书** | 扩展验证 | 金融机构、大型企业 | 极高 | 高 |

### 2.3 证书链结构

```
根证书 (Root CA)
    ↓
中间证书 (Intermediate CA)
    ↓
服务器证书 (Server Certificate)
```

**证书链说明**：
- **根证书**：信任链的起点，预安装在操作系统和浏览器中
- **中间证书**：由根证书签发，用于签发服务器证书
- **服务器证书**：用于服务器身份验证，由中间证书签发

### 2.4 密钥类型对比

| 密钥类型 | 密钥长度 | 安全性 | 性能 | 推荐场景 |
|----------|----------|--------|------|----------|
| **RSA-2048** | 2048 位 | 中 | 中 | 兼容性要求高的场景 |
| **RSA-4096** | 4096 位 | 高 | 低 | 高安全性要求 |
| **ECDSA-P-256** | 256 位 | 高 | 高 | 现代浏览器和客户端 |
| **ECDSA-P-384** | 384 位 | 极高 | 高 | 高安全性要求 |
| **Ed25519** | 256 位 | 极高 | 极高 | 现代应用（兼容性有限） |

---

## 3. 单域名证书概述

### 3.1 什么是单域名证书

单域名证书是指仅保护一个特定域名的 SSL/TLS 证书。与通配符证书（*.example.com）或多域名证书（SAN 证书）不同，单域名证书只能用于一个完全限定域名（FQDN）。

**示例**：
- 单域名证书：`mail.example.com`
- 通配符证书：`*.example.com`（包含 mail.example.com, www.example.com 等）
- 多域名证书：`mail.example.com` + `www.example.com` + `api.example.com`

### 3.2 单域名证书的特点

| 特点 | 说明 |
|------|------|
| **精确匹配** | 证书只能用于指定的单个域名 |
| **简单管理** | 配置简单，易于维护 |
| **成本低** | 相比多域名证书成本更低 |
| **安全性高** | 攻击面小，仅保护一个域名 |
| **适用性广** | 适用于大多数单站点场景 |

### 3.3 适用场景

| 场景 | 适用性 | 说明 |
|------|--------|------|
| **邮件服务器** | ✅ 适用 | SMTP/IMAP/POP3 服务器 |
| **API 服务** | ✅ 适用 | 单一 API 端点 |
| **内部系统** | ✅ 适用 | 内部管理系统 |
| **测试环境** | ✅ 适用 | 开发和测试环境 |
| **多站点部署** | ❌ 不适用 | 需要多域名或通配符证书 |

### 3.4 SMTP 隧道代理中的证书

在 SMTP 隧道代理系统中，证书用于：
- **服务器端**：保护 SMTP 服务器（端口 587）的 TLS 通信
- **客户端**：验证服务器身份，防止中间人攻击
- **加密通信**：确保邮件传输的机密性和完整性

---

## 4. 证书生成流程

### 4.1 使用项目脚本生成证书

SMTP 隧道代理项目提供了 `generate_certs.py` 脚本，用于生成自签名证书。

#### 4.1.1 基本使用

```bash
# 使用默认参数生成证书
python3 generate_certs.py

# 指定主机名
python3 generate_certs.py --hostname mail.example.com

# 指定输出目录
python3 generate_certs.py --output-dir ./cert

# 指定密钥大小和有效期
python3 generate_certs.py --key-size 4096 --days 365

# 完整示例
python3 generate_certs.py \
    --hostname mail.example.com \
    --output-dir ./cert \
    --key-size 2048 \
    --days 1095
```

#### 4.1.2 生成参数说明

| 参数 | 说明 | 默认值 | 推荐值 |
|------|------|--------|--------|
| `--hostname` | 服务器主机名 | mail.example.com | 实际域名 |
| `--output-dir` | 输出目录 | 当前目录 | ./cert |
| `--days` | 证书有效期（天） | 1095 (3年) | 1095-3650 |
| `--key-size` | RSA 密钥大小（位） | 2048 | 2048 或 4096 |

#### 4.1.3 生成的文件

执行脚本后，将生成以下文件：

| 文件 | 说明 | 用途 |
|------|------|------|
| `ca.key` | CA 私钥 | 签发其他证书（保密） |
| `ca.crt` | CA 证书 | 客户端验证服务器证书 |
| `server.key` | 服务器私钥 | 服务器 TLS 握手（保密） |
| `server.crt` | 服务器证书 | 服务器身份验证 |

### 4.2 使用 OpenSSL 生成证书

如果需要更灵活的控制，可以使用 OpenSSL 手动生成证书。

#### 4.2.1 生成 CA 证书

```bash
# 1. 生成 CA 私钥
openssl genrsa -out ca.key 4096

# 2. 生成 CA 证书
openssl req -new -x509 -days 3650 -key ca.key -out ca.crt \
    -subj "/C=CN/ST=Beijing/L=Beijing/O=SMTP Tunnel/OU=Security/CN=SMTP Tunnel CA"

# 3. 查看 CA 证书信息
openssl x509 -in ca.crt -noout -text
```

**CA 证书配置说明**：
- `-days 3650`：CA 证书有效期 10 年
- `-x509`：生成自签名证书
- `-subj`：证书主题信息

#### 4.2.2 生成服务器证书

```bash
# 1. 生成服务器私钥
openssl genrsa -out server.key 2048

# 2. 生成证书签名请求（CSR）
openssl req -new -key server.key -out server.csr \
    -subj "/C=CN/ST=Beijing/L=Beijing/O=Example Mail Services/OU=IT/CN=mail.example.com"

# 3. 创建配置文件（包含 SAN 扩展）
cat > server.conf <<EOF
[req]
distinguished_name = req_distinguished_name
req_extensions = v3_req
prompt = no

[req_distinguished_name]
C = CN
ST = Beijing
L = Beijing
O = Example Mail Services
OU = IT
CN = mail.example.com

[v3_req]
keyUsage = keyEncipherment, dataEncipherment
extendedKeyUsage = serverAuth
subjectAltName = @alt_names

[alt_names]
DNS.1 = mail.example.com
DNS.2 = smtp.example.com
DNS.3 = localhost
EOF

# 4. 使用 CA 签发服务器证书
openssl x509 -req -days 1095 -in server.csr \
    -CA ca.crt -CAkey ca.key -CAcreateserial \
    -out server.crt -extensions v3_req -extfile server.conf

# 5. 验证证书
openssl verify -CAfile ca.crt server.crt
```

**服务器证书配置说明**：
- `-days 1095`：服务器证书有效期 3 年
- `-CAcreateserial`：创建 CA 序列号文件
- `subjectAltName`：主题备用名称（SAN）

#### 4.2.3 查看证书信息

```bash
# 查看证书详细信息
openssl x509 -in server.crt -noout -text

# 查看证书有效期
openssl x509 -in server.crt -noout -dates

# 查看证书主题
openssl x509 -in server.crt -noout -subject

# 查看证书颁发者
openssl x509 -in server.crt -noout -issuer

# 查看证书序列号
openssl x509 -in server.crt -noout -serial

# 查看证书指纹
openssl x509 -in server.crt -noout -fingerprint
```

### 4.3 证书生成最佳实践

#### 4.3.1 密钥管理

| 实践 | 说明 |
|------|------|
| **使用强密钥** | 推荐使用 RSA-2048 或 RSA-4096 |
| **保护私钥** | 私钥文件权限设置为 600 |
| **定期轮换** | 每 1-2 年轮换一次密钥 |
| **备份私钥** | 安全备份私钥到离线存储 |

#### 4.3.2 证书配置

| 实践 | 说明 |
|------|------|
| **包含 SAN** | 确保证书包含主题备用名称 |
| **设置合理有效期** | 服务器证书 1-3 年，CA 证书 5-10 年 |
| **使用 SHA-256** | 签名算法使用 SHA-256 或更高 |
| **包含必要扩展** | Key Usage, Extended Key Usage, SAN |

#### 4.3.3 安全措施

| 实践 | 说明 |
|------|------|
| **加密私钥** | 使用密码加密私钥（可选） |
| **限制访问** | 仅授权人员可访问私钥 |
| **安全传输** | 使用安全通道传输证书 |
| **审计日志** | 记录证书生成和使用日志 |

---

## 5. 证书配置方法

### 5.1 服务器端配置

#### 5.1.1 配置文件设置

在 `config.yaml` 中配置证书路径：

```yaml
server:
  # 监听地址
  host: "0.0.0.0"
  
  # SMTP 提交端口
  port: 587
  
  # 服务器主机名（必须与证书 CN 或 SAN 匹配）
  hostname: "mail.example.com"
  
  # TLS 证书和密钥文件
  cert_file: "cert/server.crt"
  key_file: "cert/server.key"
  
  # 用户配置文件
  users_file: "users.yaml"
```

**配置说明**：
- `hostname`：必须与证书的 CN 或 SAN 完全匹配
- `cert_file`：服务器证书文件路径
- `key_file`：服务器私钥文件路径

#### 5.1.2 证书文件权限

```bash
# 设置证书文件权限
chmod 644 cert/server.crt      # 证书文件：所有者读写，其他人只读
chmod 600 cert/server.key      # 私钥文件：仅所有者读写
chmod 644 cert/ca.crt          # CA 证书：所有者读写，其他人只读

# 验证文件权限
ls -la cert/
```

**权限说明**：
| 文件 | 权限 | 说明 |
|------|------|------|
| `server.crt` | 644 | 所有者读写，其他人只读 |
| `server.key` | 600 | 仅所有者读写（保密） |
| `ca.crt` | 644 | 所有者读写，其他人只读 |

#### 5.1.3 启动服务器

```bash
# 使用配置文件启动服务器
python3 server.py --config config.yaml

# 或使用默认配置
python3 server.py
```

### 5.2 客户端配置

#### 5.2.1 配置文件设置

在客户端配置中指定 CA 证书路径：

```yaml
client:
  # 隧道服务器域名（必须与证书 CN 或 SAN 匹配）
  server_host: "mail.example.com"
  
  # 隧道服务器端口
  server_port: 587
  
  # 本地 SOCKS5 代理端口
  socks_port: 1080
  
  # 本地 SOCKS5 绑定地址
  socks_host: "127.0.0.1"
  
  # 用户凭证
  username: "your_username"
  secret: "your_secret"
  
  # 用于服务器验证的 CA 证书
  ca_cert: "cert/ca.crt"
```

**配置说明**：
- `server_host`：必须与证书的 CN 或 SAN 完全匹配
- `ca_cert`：CA 证书文件路径（用于验证服务器证书）

#### 5.2.2 证书验证模式

客户端支持两种证书验证模式：

| 模式 | 说明 | 安全性 | 配置 |
|------|------|--------|------|
| **严格验证** | 验证服务器证书 | 高 | 提供 `ca_cert` |
| **跳过验证** | 不验证服务器证书 | 低 | 不提供 `ca_cert` 或设置 `verify: false` |

**推荐**：生产环境始终使用严格验证模式。

#### 5.2.3 启动客户端

```bash
# 使用配置文件启动客户端
python3 client.py --config client_config.yaml

# 或使用命令行参数
python3 client.py \
    --server-host mail.example.com \
    --server-port 587 \
    --socks-port 1080 \
    --username your_username \
    --secret your_secret \
    --ca-cert cert/ca.crt
```

### 5.3 高级配置

#### 5.3.1 TLS 协议版本

```yaml
# 在配置文件中指定 TLS 协议版本
server:
  tls:
    # 支持的 TLS 版本
    min_version: "TLSv1.2"
    max_version: "TLSv1.3"
    
    # 支持的加密套件
    ciphers:
      - "ECDHE-RSA-AES128-GCM-SHA256"
      - "ECDHE-RSA-AES256-GCM-SHA384"
      - "ECDHE-ECDSA-AES128-GCM-SHA256"
```

#### 5.3.2 会话恢复

```yaml
# 配置 TLS 会话恢复
server:
  tls:
    # 会话缓存大小
    session_cache_size: 1000
    
    # 会话超时时间（秒）
    session_timeout: 300
    
    # 会话票据
    session_tickets: true
```

#### 5.3.3 OCSP Stapling

```yaml
# 配置 OCSP Stapling（如果使用受信任 CA）
server:
  tls:
    # 启用 OCSP Stapling
    ocsp_stapling: true
    
    # OCSP 响应超时（秒）
    ocsp_timeout: 5
    
    # OCSP 响应缓存时间（秒）
    ocsp_cache_time: 3600
```

---

## 6. 证书验证方法

### 6.1 验证证书有效性

#### 6.1.1 使用 OpenSSL 验证

```bash
# 验证证书链
openssl verify -CAfile ca.crt server.crt

# 验证证书有效期
openssl x509 -in server.crt -noout -dates

# 验证证书主题
openssl x509 -in server.crt -noout -subject

# 验证证书颁发者
openssl x509 -in server.crt -noout -issuer

# 验证证书序列号
openssl x509 -in server.crt -noout -serial

# 验证证书指纹
openssl x509 -in server.crt -noout -fingerprint
```

#### 6.1.2 验证证书和私钥匹配

```bash
# 方法 1：比较模数
openssl x509 -noout -modulus -in server.crt | openssl md5
openssl rsa -noout -modulus -in server.key | openssl md5

# 如果两个 MD5 值相同，则证书和私钥匹配

# 方法 2：使用 OpenSSL 验证
openssl x509 -noout -text -in server.crt | grep -A 1 "Public-Key"
openssl rsa -in server.key -noout -text | grep -A 1 "Private-Key"
```

### 6.2 验证服务器证书

#### 6.2.1 使用 OpenSSL 连接测试

```bash
# 测试 TLS 连接
openssl s_client -connect mail.example.com:587 -showcerts

# 测试 TLS 连接并验证证书
openssl s_client -connect mail.example.com:587 \
    -CAfile ca.crt \
    -verify_return_error

# 测试 TLS 连接并显示证书链
openssl s_client -connect mail.example.com:587 \
    -showcerts \
    -CAfile ca.crt

# 测试 TLS 连接并显示会话信息
openssl s_client -connect mail.example.com:587 \
    -showcerts \
    -CAfile ca.crt \
    -tlsextdebug
```

#### 6.2.2 使用 GnuTLS 测试

```bash
# 安装 GnuTLS
sudo apt-get install gnutls-bin

# 测试 TLS 连接
gnutls-cli --print-cert mail.example.com:587

# 测试 TLS 连接并验证证书
gnutls-cli --print-cert --x509cafile ca.crt mail.example.com:587
```

### 6.3 验证证书链

#### 6.3.1 检查证书链完整性

```bash
# 创建完整证书链
cat server.crt intermediate.crt > fullchain.crt

# 验证完整证书链
openssl verify -CAfile ca.crt fullchain.crt

# 查看证书链
openssl s_client -connect mail.example.com:587 -showcerts
```

#### 6.3.2 验证证书链顺序

```bash
# 检查证书链顺序
# 正确顺序：服务器证书 -> 中间证书 -> 根证书

# 使用 OpenSSL 验证
openssl verify -CAfile ca.crt -untrusted intermediate.crt server.crt
```

### 6.4 在线验证工具

| 工具 | URL | 用途 |
|------|-----|------|
| **SSL Labs SSL Test** | https://www.ssllabs.com/ssltest/ | SSL 配置评估 |
| **SSL Decoder** | https://www.sslshopper.com/ssl-decoder.html | 证书解码 |
| **Certificate Checker** | https://www.digicert.com/help/ | 证书检查 |
| **CryptoReport** | https://cryptoreport.websecurity.symantec.com/ | 证书报告 |

---

## 7. 证书有效期管理

### 7.1 检查证书有效期

#### 7.1.1 使用 OpenSSL 检查

```bash
# 检查证书有效期
openssl x509 -in server.crt -noout -dates

# 输出示例：
# notBefore=Jan  1 00:00:00 2023 GMT
# notAfter=Jan  1 00:00:00 2026 GMT

# 计算剩余天数
EXPIRY_DATE=$(openssl x509 -in server.crt -noout -enddate | cut -d= -f2)
EXPIRY_TIMESTAMP=$(date -d "$EXPIRY_DATE" +%s)
CURRENT_TIMESTAMP=$(date +%s)
DAYS_LEFT=$(( (EXPIRY_TIMESTAMP - CURRENT_TIMESTAMP) / 86400 ))

echo "证书剩余天数: $DAYS_LEFT"
```

#### 7.1.2 使用 Python 检查

```python
#!/usr/bin/env python3
"""
检查证书有效期脚本
"""

import ssl
import socket
from datetime import datetime, timedelta
from cryptography import x509
from cryptography.hazmat.backends import default_backend

def check_cert_expiry(cert_file):
    """检查证书文件的有效期"""
    with open(cert_file, 'rb') as f:
        cert = x509.load_pem_x509_certificate(f.read(), default_backend())
    
    # 获取有效期
    not_before = cert.not_valid_before
    not_after = cert.not_valid_after
    
    # 计算剩余天数
    now = datetime.utcnow()
    days_left = (not_after - now).days
    
    print(f"证书文件: {cert_file}")
    print(f"生效时间: {not_before}")
    print(f"过期时间: {not_after}")
    print(f"剩余天数: {days_left}")
    
    if days_left < 0:
        print("警告: 证书已过期!")
    elif days_left < 30:
        print(f"警告: 证书将在 {days_left} 天内过期!")
    else:
        print("证书状态: 正常")
    
    return days_left

def check_server_cert(hostname, port=587):
    """检查服务器证书的有效期"""
    context = ssl.create_default_context()
    with socket.create_connection((hostname, port), timeout=10) as sock:
        with context.wrap_socket(sock, server_hostname=hostname) as ssock:
            cert = ssock.getpeercert()
            
            # 获取有效期
            not_before = datetime.strptime(cert['notBefore'], '%b %d %H:%M:%S %Y %Z')
            not_after = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
            
            # 计算剩余天数
            now = datetime.utcnow()
            days_left = (not_after - now).days
            
            print(f"服务器: {hostname}:{port}")
            print(f"生效时间: {not_before}")
            print(f"过期时间: {not_after}")
            print(f"剩余天数: {days_left}")
            
            if days_left < 0:
                print("警告: 证书已过期!")
            elif days_left < 30:
                print(f"警告: 证书将在 {days_left} 天内过期!")
            else:
                print("证书状态: 正常")
            
            return days_left

if __name__ == '__main__':
    # 检查证书文件
    check_cert_expiry('cert/server.crt')
    
    # 检查服务器证书
    check_server_cert('mail.example.com', 587)
```

### 7.2 证书监控

#### 7.2.1 Bash 监控脚本

```bash
#!/bin/bash
# cert-monitor.sh - 证书有效期监控脚本

set -euo pipefail

# 配置
CERT_FILE="cert/server.crt"
WARNING_DAYS=30
ALERT_EMAIL="admin@example.com"

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

# 日志函数
log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# 检查证书有效期
check_cert_expiry() {
    local cert_file="$1"
    
    if [ ! -f "$cert_file" ]; then
        log_error "证书文件不存在: $cert_file"
        return 1
    fi
    
    # 获取过期时间
    local expiry_date=$(openssl x509 -in "$cert_file" -noout -enddate | cut -d= -f2)
    local expiry_timestamp=$(date -d "$expiry_date" +%s)
    local current_timestamp=$(date +%s)
    local days_left=$(( (expiry_timestamp - current_timestamp) / 86400 ))
    
    log_info "证书文件: $cert_file"
    log_info "过期时间: $expiry_date"
    log_info "剩余天数: $days_left"
    
    if [ $days_left -lt 0 ]; then
        log_error "证书已过期!"
        return 1
    elif [ $days_left -lt $WARNING_DAYS ]; then
        log_warn "警告: 证书将在 $days_left 天内过期!"
        
        # 发送告警邮件
        if [ -n "$ALERT_EMAIL" ]; then
            echo "证书 $cert_file 将在 $days_left 天后过期。" | \
                mail -s "证书即将过期告警" "$ALERT_EMAIL"
        fi
        return 1
    else
        log_info "证书状态: 正常"
        return 0
    fi
}

# 主函数
main() {
    check_cert_expiry "$CERT_FILE"
}

# 执行主函数
main
```

#### 7.2.2 Python 监控脚本

```python
#!/usr/bin/env python3
"""
证书监控脚本 - 监控证书有效期并发送告警
"""

import ssl
import socket
import smtplib
from datetime import datetime, timedelta
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from cryptography import x509
from cryptography.hazmat.backends import default_backend

class CertificateMonitor:
    """证书监控类"""
    
    def __init__(self, warning_days=30, alert_email=None):
        """
        初始化证书监控
        
        Args:
            warning_days: 告警天数阈值
            alert_email: 告警邮箱
        """
        self.warning_days = warning_days
        self.alert_email = alert_email
    
    def check_cert_file(self, cert_file):
        """
        检查证书文件的有效期
        
        Args:
            cert_file: 证书文件路径
        
        Returns:
            dict: 包含证书信息的字典
        """
        try:
            with open(cert_file, 'rb') as f:
                cert = x509.load_pem_x509_certificate(f.read(), default_backend())
            
            # 获取有效期
            not_before = cert.not_valid_before
            not_after = cert.not_valid_after
            
            # 计算剩余天数
            now = datetime.utcnow()
            days_left = (not_after - now).days
            
            result = {
                'cert_file': cert_file,
                'not_before': not_before,
                'not_after': not_after,
                'days_left': days_left,
                'status': 'valid' if days_left >= 0 else 'expired'
            }
            
            # 检查是否需要告警
            if days_left < 0:
                result['alert'] = True
                result['message'] = f"证书已过期 {abs(days_left)} 天"
            elif days_left < self.warning_days:
                result['alert'] = True
                result['message'] = f"证书将在 {days_left} 天内过期"
            else:
                result['alert'] = False
                result['message'] = "证书状态正常"
            
            return result
        except Exception as e:
            return {
                'cert_file': cert_file,
                'error': str(e),
                'status': 'error',
                'alert': True,
                'message': f"检查证书失败: {str(e)}"
            }
    
    def check_server_cert(self, hostname, port=587):
        """
        检查服务器证书的有效期
        
        Args:
            hostname: 服务器主机名
            port: 服务器端口
        
        Returns:
            dict: 包含证书信息的字典
        """
        try:
            context = ssl.create_default_context()
            with socket.create_connection((hostname, port), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    cert = ssock.getpeercert()
                    
                    # 获取有效期
                    not_before = datetime.strptime(
                        cert['notBefore'],
                        '%b %d %H:%M:%S %Y %Z'
                    )
                    not_after = datetime.strptime(
                        cert['notAfter'],
                        '%b %d %H:%M:%S %Y %Z'
                    )
                    
                    # 计算剩余天数
                    now = datetime.utcnow()
                    days_left = (not_after - now).days
                    
                    result = {
                        'hostname': hostname,
                        'port': port,
                        'not_before': not_before,
                        'not_after': not_after,
                        'days_left': days_left,
                        'status': 'valid' if days_left >= 0 else 'expired'
                    }
                    
                    # 检查是否需要告警
                    if days_left < 0:
                        result['alert'] = True
                        result['message'] = f"证书已过期 {abs(days_left)} 天"
                    elif days_left < self.warning_days:
                        result['alert'] = True
                        result['message'] = f"证书将在 {days_left} 天内过期"
                    else:
                        result['alert'] = False
                        result['message'] = "证书状态正常"
                    
                    return result
        except Exception as e:
            return {
                'hostname': hostname,
                'port': port,
                'error': str(e),
                'status': 'error',
                'alert': True,
                'message': f"检查证书失败: {str(e)}"
            }
    
    def send_alert(self, result):
        """
        发送告警邮件
        
        Args:
            result: 证书检查结果
        """
        if not self.alert_email:
            return
        
        # 构建邮件
        msg = MIMEMultipart()
        msg['From'] = 'cert-monitor@example.com'
        msg['To'] = self.alert_email
        
        # 设置主题
        if 'cert_file' in result:
            subject = f"证书告警: {result['cert_file']}"
        else:
            subject = f"证书告警: {result['hostname']}:{result['port']}"
        
        msg['Subject'] = subject
        
        # 构建邮件正文
        body = f"""
证书监控告警
{'=' * 50}

{result['message']}

详细信息:
"""
        
        if 'cert_file' in result:
            body += f"证书文件: {result['cert_file']}\n"
        if 'hostname' in result:
            body += f"服务器: {result['hostname']}:{result['port']}\n"
        if 'not_before' in result:
            body += f"生效时间: {result['not_before']}\n"
        if 'not_after' in result:
            body += f"过期时间: {result['not_after']}\n"
        if 'days_left' in result:
            body += f"剩余天数: {result['days_left']}\n"
        
        msg.attach(MIMEText(body, 'plain'))
        
        # 发送邮件（需要配置 SMTP 服务器）
        # with smtplib.SMTP('smtp.example.com', 587) as server:
        #     server.starttls()
        #     server.login('user', 'password')
        #     server.send_message(msg)
        #     server.quit()
        
        print(f"告警邮件已发送到: {self.alert_email}")
    
    def monitor(self, targets):
        """
        监控多个证书
        
        Args:
            targets: 目标列表，可以是证书文件路径或 (hostname, port) 元组
        """
        print("开始证书监控...")
        print("=" * 50)
        
        for target in targets:
            if isinstance(target, str):
                # 检查证书文件
                result = self.check_cert_file(target)
            elif isinstance(target, tuple):
                # 检查服务器证书
                result = self.check_server_cert(*target)
            else:
                print(f"无效的目标: {target}")
                continue
            
            # 打印结果
            print(f"\n目标: {target}")
            print(f"状态: {result.get('status', 'unknown')}")
            print(f"消息: {result['message']}")
            
            if 'not_after' in result:
                print(f"过期时间: {result['not_after']}")
            if 'days_left' in result:
                print(f"剩余天数: {result['days_left']}")
            
            # 发送告警
            if result.get('alert'):
                self.send_alert(result)

if __name__ == '__main__':
    # 创建监控器
    monitor = CertificateMonitor(
        warning_days=30,
        alert_email='admin@example.com'
    )
    
    # 监控目标
    targets = [
        'cert/server.crt',
        ('mail.example.com', 587),
    ]
    
    # 执行监控
    monitor.monitor(targets)
```

### 7.3 自动化监控

#### 7.3.1 使用 Cron 定时任务

```bash
# 编辑 crontab
crontab -e

# 添加定时任务（每天凌晨 2 点检查证书）
0 2 * * * /path/to/cert-monitor.sh >> /var/log/cert-monitor.log 2>&1

# 每周检查一次
0 2 * * 0 /path/to/cert-monitor.sh >> /var/log/cert-monitor.log 2>&1

# 每月检查一次
0 2 1 * * /path/to/cert-monitor.sh >> /var/log/cert-monitor.log 2>&1
```

#### 7.3.2 使用 Systemd 定时器

```bash
# 创建 systemd 服务文件
sudo cat > /etc/systemd/system/cert-monitor.service <<EOF
[Unit]
Description=Certificate Monitor Service
After=network.target

[Service]
Type=oneshot
ExecStart=/path/to/cert-monitor.sh
User=root
Group=root

[Install]
WantedBy=multi-user.target
EOF

# 创建 systemd 定时器文件
sudo cat > /etc/systemd/system/cert-monitor.timer <<EOF
[Unit]
Description=Certificate Monitor Timer

[Timer]
OnCalendar=daily
Persistent=true

[Install]
WantedBy=timers.target
EOF

# 启用并启动定时器
sudo systemctl enable cert-monitor.timer
sudo systemctl start cert-monitor.timer

# 查看定时器状态
sudo systemctl status cert-monitor.timer
sudo systemctl list-timers
```

---

## 8. 证书更新机制

### 8.1 手动更新流程

#### 8.1.1 更新步骤

```bash
# 1. 备份现有证书
mkdir -p cert/backup/$(date +%Y%m%d)
cp cert/server.crt cert/backup/$(date +%Y%m%d)/
cp cert/server.key cert/backup/$(date +%Y%m%d)/

# 2. 生成新的证书
python3 generate_certs.py \
    --hostname mail.example.com \
    --output-dir cert \
    --key-size 2048 \
    --days 1095

# 3. 验证新证书
openssl verify -CAfile cert/ca.crt cert/server.crt
openssl x509 -in cert/server.crt -noout -dates

# 4. 重启服务
sudo systemctl restart smtp-tunnel-server

# 5. 验证服务
openssl s_client -connect mail.example.com:587 -showcerts
```

#### 8.1.2 更新检查清单

| 检查项 | 说明 | 状态 |
|--------|------|------|
| 备份现有证书 | 备份到安全位置 | ☐ |
| 生成新证书 | 使用正确的参数 | ☐ |
| 验证新证书 | 检查证书有效性 | ☐ |
| 更新配置文件 | 确认证书路径正确 | ☐ |
| 重启服务 | 重启 SMTP 隧道服务 | ☐ |
| 验证服务 | 测试 TLS 连接 | ☐ |
| 更新客户端 | 分发新的 CA 证书（如需要） | ☐ |
| 记录更新 | 记录更新日志 | ☐ |

### 8.2 自动更新脚本

#### 8.2.1 Bash 自动更新脚本

```bash
#!/bin/bash
# cert-renew.sh - 证书自动更新脚本

set -euo pipefail

# 配置
CERT_DIR="cert"
BACKUP_DIR="cert/backup"
DOMAIN="mail.example.com"
WARNING_DAYS=30
KEY_SIZE=2048
CERT_DAYS=1095

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

# 日志函数
log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# 检查证书有效期
check_cert_expiry() {
    local cert_file="$1"
    
    if [ ! -f "$cert_file" ]; then
        log_error "证书文件不存在: $cert_file"
        return 1
    fi
    
    # 获取过期时间
    local expiry_date=$(openssl x509 -in "$cert_file" -noout -enddate | cut -d= -f2)
    local expiry_timestamp=$(date -d "$expiry_date" +%s)
    local current_timestamp=$(date +%s)
    local days_left=$(( (expiry_timestamp - current_timestamp) / 86400 ))
    
    log_info "证书过期时间: $expiry_date"
    log_info "剩余天数: $days_left"
    
    if [ $days_left -lt $WARNING_DAYS ]; then
        log_warn "证书需要更新"
        return 1
    fi
    
    log_info "证书有效期充足，无需更新"
    return 0
}

# 备份证书
backup_cert() {
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_dir="$BACKUP_DIR/$timestamp"
    
    mkdir -p "$backup_dir"
    
    log_info "备份证书到: $backup_dir"
    cp "$CERT_DIR/server.crt" "$backup_dir/"
    cp "$CERT_DIR/server.key" "$backup_dir/"
    cp "$CERT_DIR/ca.crt" "$backup_dir/"
    
    log_info "备份完成"
}

# 更新证书
renew_cert() {
    log_info "开始更新证书"
    
    # 备份现有证书
    backup_cert
    
    # 生成新的证书
    log_info "生成新的证书"
    python3 generate_certs.py \
        --hostname "$DOMAIN" \
        --output-dir "$CERT_DIR" \
        --key-size "$KEY_SIZE" \
        --days "$CERT_DAYS"
    
    # 验证新证书
    log_info "验证新证书"
    openssl verify -CAfile "$CERT_DIR/ca.crt" "$CERT_DIR/server.crt"
    
    if [ $? -eq 0 ]; then
        log_info "证书验证成功"
    else
        log_error "证书验证失败"
        exit 1
    fi
    
    # 显示新证书信息
    log_info "新证书信息:"
    openssl x509 -in "$CERT_DIR/server.crt" -noout -dates
    openssl x509 -in "$CERT_DIR/server.crt" -noout -subject
    
    # 重启服务
    log_info "重启 SMTP 隧道服务"
    sudo systemctl restart smtp-tunnel-server
    
    if [ $? -eq 0 ]; then
        log_info "服务重启成功"
    else
        log_error "服务重启失败"
        exit 1
    fi
    
    log_info "证书更新完成"
}

# 主函数
main() {
    log_info "开始证书检查"
    
    if ! check_cert_expiry "$CERT_DIR/server.crt"; then
        renew_cert
    fi
    
    log_info "证书检查完成"
}

# 执行主函数
main
```

#### 8.2.2 Python 自动更新脚本

```python
#!/usr/bin/env python3
"""
证书自动更新脚本
"""

import os
import sys
import shutil
import subprocess
from datetime import datetime
from cryptography import x509
from cryptography.hazmat.backends import default_backend

class CertificateRenewer:
    """证书更新类"""
    
    def __init__(self, config):
        """
        初始化证书更新器
        
        Args:
            config: 配置字典
        """
        self.cert_dir = config.get('cert_dir', 'cert')
        self.backup_dir = config.get('backup_dir', 'cert/backup')
        self.domain = config.get('domain', 'mail.example.com')
        self.warning_days = config.get('warning_days', 30)
        self.key_size = config.get('key_size', 2048)
        self.cert_days = config.get('cert_days', 1095)
    
    def check_cert_expiry(self, cert_file):
        """
        检查证书有效期
        
        Args:
            cert_file: 证书文件路径
        
        Returns:
            tuple: (是否需要更新, 剩余天数)
        """
        try:
            with open(cert_file, 'rb') as f:
                cert = x509.load_pem_x509_certificate(f.read(), default_backend())
            
            # 计算剩余天数
            now = datetime.utcnow()
            days_left = (cert.not_valid_after - now).days
            
            print(f"证书过期时间: {cert.not_valid_after}")
            print(f"剩余天数: {days_left}")
            
            if days_left < 0:
                print("警告: 证书已过期!")
                return True, days_left
            elif days_left < self.warning_days:
                print(f"警告: 证书将在 {days_left} 天内过期")
                return True, days_left
            else:
                print("证书有效期充足，无需更新")
                return False, days_left
        except Exception as e:
            print(f"检查证书失败: {e}")
            return True, 0
    
    def backup_cert(self):
        """备份现有证书"""
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        backup_path = os.path.join(self.backup_dir, timestamp)
        
        os.makedirs(backup_path, exist_ok=True)
        
        print(f"备份证书到: {backup_path}")
        
        # 备份证书文件
        files_to_backup = [
            'server.crt',
            'server.key',
            'ca.crt',
        ]
        
        for filename in files_to_backup:
            src = os.path.join(self.cert_dir, filename)
            if os.path.exists(src):
                dst = os.path.join(backup_path, filename)
                shutil.copy2(src, dst)
                print(f"  已备份: {filename}")
        
        print("备份完成")
    
    def generate_cert(self):
        """生成新的证书"""
        print("生成新的证书")
        
        # 构建命令
        cmd = [
            'python3',
            'generate_certs.py',
            '--hostname', self.domain,
            '--output-dir', self.cert_dir,
            '--key-size', str(self.key_size),
            '--days', str(self.cert_days),
        ]
        
        # 执行命令
        result = subprocess.run(cmd, capture_output=True, text=True)
        
        if result.returncode != 0:
            print(f"生成证书失败: {result.stderr}")
            return False
        
        print(result.stdout)
        print("证书生成完成")
        return True
    
    def verify_cert(self):
        """验证新证书"""
        print("验证新证书")
        
        cert_file = os.path.join(self.cert_dir, 'server.crt')
        ca_file = os.path.join(self.cert_dir, 'ca.crt')
        
        # 使用 OpenSSL 验证
        cmd = [
            'openssl',
            'verify',
            '-CAfile', ca_file,
            cert_file,
        ]
        
        result = subprocess.run(cmd, capture_output=True, text=True)
        
        if result.returncode != 0:
            print(f"证书验证失败: {result.stderr}")
            return False
        
        print("证书验证成功")
        
        # 显示证书信息
        print("\n新证书信息:")
        subprocess.run([
            'openssl', 'x509', '-in', cert_file,
            '-noout', '-dates', '-subject'
        ])
        
        return True
    
    def restart_service(self):
        """重启服务"""
        print("重启 SMTP 隧道服务")
        
        cmd = ['sudo', 'systemctl', 'restart', 'smtp-tunnel-server']
        result = subprocess.run(cmd, capture_output=True, text=True)
        
        if result.returncode != 0:
            print(f"服务重启失败: {result.stderr}")
            return False
        
        print("服务重启成功")
        return True
    
    def renew(self):
        """执行证书更新"""
        print("开始证书检查")
        print("=" * 50)
        
        cert_file = os.path.join(self.cert_dir, 'server.crt')
        
        # 检查证书有效期
        need_renew, days_left = self.check_cert_expiry(cert_file)
        
        if not need_renew:
            print("证书检查完成")
            return True
        
        print("\n开始更新证书")
        print("=" * 50)
        
        # 备份现有证书
        self.backup_cert()
        
        # 生成新证书
        if not self.generate_cert():
            return False
        
        # 验证新证书
        if not self.verify_cert():
            return False
        
        # 重启服务
        if not self.restart_service():
            return False
        
        print("\n证书更新完成")
        return True

if __name__ == '__main__':
    # 配置
    config = {
        'cert_dir': 'cert',
        'backup_dir': 'cert/backup',
        'domain': 'mail.example.com',
        'warning_days': 30,
        'key_size': 2048,
        'cert_days': 1095,
    }
    
    # 创建更新器
    renewer = CertificateRenewer(config)
    
    # 执行更新
    success = renewer.renew()
    
    # 退出
    sys.exit(0 if success else 1)
```

### 8.3 自动化更新部署

#### 8.3.1 使用 Cron 定时更新

```bash
# 编辑 crontab
crontab -e

# 添加定时任务（每周日凌晨 2 点检查并更新证书）
0 2 * * 0 /path/to/cert-renew.sh >> /var/log/cert-renew.log 2>&1

# 每月检查一次
0 2 1 * * /path/to/cert-renew.sh >> /var/log/cert-renew.log 2>&1
```

#### 8.3.2 使用 Systemd 定时器

```bash
# 创建 systemd 服务文件
sudo cat > /etc/systemd/system/cert-renew.service <<EOF
[Unit]
Description=Certificate Renewal Service
After=network.target

[Service]
Type=oneshot
ExecStart=/path/to/cert-renew.sh
User=root
Group=root

[Install]
WantedBy=multi-user.target
EOF

# 创建 systemd 定时器文件
sudo cat > /etc/systemd/system/cert-renew.timer <<EOF
[Unit]
Description=Certificate Renewal Timer

[Timer]
OnCalendar=weekly
Persistent=true

[Install]
WantedBy=timers.target
EOF

# 启用并启动定时器
sudo systemctl enable cert-renew.timer
sudo systemctl start cert-renew.timer

# 查看定时器状态
sudo systemctl status cert-renew.timer
```

---

## 9. 安全最佳实践

### 9.1 密钥管理

#### 9.1.1 密钥生成

| 实践 | 说明 | 推荐值 |
|------|------|--------|
| **密钥长度** | 使用足够长的密钥 | RSA-2048 或 RSA-4096 |
| **密钥类型** | 选择合适的密钥类型 | RSA 或 ECDSA |
| **随机数生成** | 使用安全的随机数生成器 | 操作系统提供的 CSPRNG |
| **密钥格式** | 使用标准格式 | PEM 或 PKCS#12 |

#### 9.1.2 密钥存储

| 实践 | 说明 | 推荐做法 |
|------|------|----------|
| **文件权限** | 限制私钥文件访问 | 600 (仅所有者读写) |
| **文件所有权** | 设置正确的所有者 | root:root |
| **加密存储** | 使用密码加密私钥 | 可选但推荐 |
| **备份策略** | 安全备份私钥 | 加密存储到离线位置 |

```bash
# 设置正确的文件权限
chmod 600 cert/server.key
chmod 644 cert/server.crt
chmod 644 cert/ca.crt

# 设置文件所有权
chown root:root cert/server.key
chown root:root cert/server.crt
chown root:root cert/ca.crt

# 验证文件权限
ls -la cert/
```

#### 9.1.3 密钥轮换

| 实践 | 说明 | 推荐频率 |
|------|------|----------|
| **定期轮换** | 定期更换密钥 | 每 1-2 年 |
| **事件触发** | 在安全事件后立即轮换 | 立即 |
| **渐进式轮换** | 逐步替换密钥 | 推荐方式 |
| **密钥销毁** | 安全销毁旧密钥 | 使用安全删除工具 |

### 9.2 证书配置

#### 9.2.1 证书参数

| 参数 | 说明 | 推荐值 |
|------|------|--------|
| **密钥长度** | RSA 密钥长度 | 2048 或 4096 位 |
| **签名算法** | 证书签名算法 | SHA-256 或 SHA-384 |
| **有效期** | 证书有效期 | 1-3 年（服务器），5-10 年（CA） |
| **扩展字段** | 证书扩展 | SAN, Key Usage, EKU |

#### 9.2.2 证书扩展

| 扩展 | 说明 | 必需/可选 |
|------|------|-----------|
| **Subject Alternative Name (SAN)** | 主题备用名称 | 必需 |
| **Key Usage** | 密钥用法 | 必需 |
| **Extended Key Usage** | 扩展密钥用法 | 必需 |
| **Basic Constraints** | 基本约束 | 必需 |
| **Subject Key Identifier** | 主题密钥标识符 | 推荐 |
| **Authority Key Identifier** | 颁发者密钥标识符 | 推荐 |

#### 9.2.3 TLS 配置

| 配置 | 说明 | 推荐值 |
|------|------|--------|
| **TLS 版本** | 支持的 TLS 版本 | TLS 1.2, TLS 1.3 |
| **加密套件** | 支持的加密算法 | ECDHE, AES-GCM |
| **会话恢复** | TLS 会话恢复 | 启用 |
| **OCSP Stapling** | OCSP 装订 | 启用（如果使用受信任 CA） |

### 9.3 访问控制

#### 9.3.1 文件系统权限

```bash
# 证书目录权限
chmod 755 cert/

# 私钥文件权限
chmod 600 cert/server.key

# 证书文件权限
chmod 644 cert/server.crt
chmod 644 cert/ca.crt

# 验证权限
ls -la cert/
```

#### 9.3.2 SELinux 配置

```bash
# 检查 SELinux 状态
sestatus

# 设置 SELinux 上下文
chcon -u system_u -r object_r -t cert_t cert/server.key
chcon -u system_u -r object_r -t cert_t cert/server.crt
chcon -u system_u -r object_r -t cert_t cert/ca.crt

# 验证 SELinux 上下文
ls -Z cert/
```

#### 9.3.3 AppArmor 配置

```bash
# 创建 AppArmor 配置文件
sudo cat > /etc/apparmor.d/usr.local.bin.smtp-tunnel-server <<EOF
#include <tunables/global>

/usr/local/bin/smtp-tunnel-server {
  #include <abstractions/base>
  
  # 证书文件访问
  /etc/ssl/certs/** r,
  /etc/ssl/private/** r,
  /path/to/cert/** r,
  
  # 网络访问
  network inet stream,
  
  # 其他权限
  deny /proc/sys/kernel/** w,
}
EOF

# 加载 AppArmor 配置
sudo apparmor_parser -r /etc/apparmor.d/usr.local.bin.smtp-tunnel-server
```

### 9.4 审计与监控

#### 9.4.1 日志记录

```bash
# 配置日志记录
# 在 config.yaml 中设置日志级别
logging:
  level: "INFO"
  log_dir: "/var/log/smtp-tunnel"
  log_file: "smtp-tunnel.log"
  enable_file: true
  enable_console: true
  enable_journal: true
```

#### 9.4.2 审计日志

```bash
# 启用审计日志
sudo auditctl -w /path/to/cert/ -p wa -k cert_access

# 查看审计日志
sudo ausearch -k cert_access
```

#### 9.4.3 监控告警

```bash
# 配置监控告警
# 使用 cert-monitor.sh 定期检查证书
# 配置邮件告警或短信告警
```

---

## 10. 常见问题解决方案

### 10.1 证书生成问题

#### 10.1.1 生成失败

**问题现象**：
```
Error: Failed to generate certificate
```

**可能原因**：
1. Python 环境问题
2. cryptography 库未安装
3. 权限不足
4. 磁盘空间不足

**解决方案**：
```bash
# 1. 检查 Python 环境
python3 --version

# 2. 安装依赖
pip3 install cryptography pyyaml

# 3. 检查权限
ls -la cert/
chmod 755 cert/

# 4. 检查磁盘空间
df -h
```

#### 10.1.2 证书参数错误

**问题现象**：
```
Error: Invalid certificate parameters
```

**可能原因**：
1. 主机名格式错误
2. 密钥大小不支持
3. 有效期设置错误

**解决方案**：
```bash
# 1. 检查主机名格式
# 主机名应为 FQDN（完全限定域名）
# 示例: mail.example.com

# 2. 检查密钥大小
# 支持的密钥大小: 2048, 4096

# 3. 检查有效期
# 有效期应为正整数（天）
# 推荐: 1095 (3年) 或 3650 (10年)
```

### 10.2 证书配置问题

#### 10.2.1 证书路径错误

**问题现象**：
```
Error: Certificate file not found: cert/server.crt
```

**可能原因**：
1. 证书文件不存在
2. 证书路径配置错误
3. 文件权限不足

**解决方案**：
```bash
# 1. 检查证书文件是否存在
ls -la cert/

# 2. 检查配置文件中的证书路径
cat config.yaml | grep cert_file
cat config.yaml | grep key_file

# 3. 检查文件权限
ls -la cert/server.crt
ls -la cert/server.key

# 4. 修正配置文件
# 确保证书路径正确
```

#### 10.2.2 证书不匹配

**问题现象**：
```
Error: Certificate does not match private key
```

**可能原因**：
1. 证书和私钥不匹配
2. 证书文件损坏
3. 私钥文件损坏

**解决方案**：
```bash
# 1. 验证证书和私钥是否匹配
openssl x509 -noout -modulus -in cert/server.crt | openssl md5
openssl rsa -noout -modulus -in cert/server.key | openssl md5

# 如果两个 MD5 值不同，说明证书和私钥不匹配

# 2. 重新生成证书
python3 generate_certs.py --hostname mail.example.com

# 3. 验证新证书
openssl verify -CAfile cert/ca.crt cert/server.crt
```

### 10.3 证书验证问题

#### 10.3.1 证书验证失败

**问题现象**：
```
Error: Certificate verification failed
```

**可能原因**：
1. CA 证书未配置
2. 证书链不完整
3. 证书已过期

**解决方案**：
```bash
# 1. 检查 CA 证书
ls -la cert/ca.crt

# 2. 验证证书链
openssl verify -CAfile cert/ca.crt cert/server.crt

# 3. 检查证书有效期
openssl x509 -in cert/server.crt -noout -dates

# 4. 如果证书已过期，重新生成证书
python3 generate_certs.py --hostname mail.example.com
```

#### 10.3.2 主机名不匹配

**问题现象**：
```
Error: Certificate hostname does not match server hostname
```

**可能原因**：
1. 证书 CN 与服务器主机名不匹配
2. 证书 SAN 未包含服务器主机名

**解决方案**：
```bash
# 1. 检查证书 CN 和 SAN
openssl x509 -in cert/server.crt -noout -text | grep -A 1 "Subject:"
openssl x509 -in cert/server.crt -noout -text | grep -A 10 "Subject Alternative Name"

# 2. 检查服务器主机名配置
cat config.yaml | grep hostname

# 3. 确保证书 CN 或 SAN 与服务器主机名匹配
# 重新生成证书，使用正确的主机名
python3 generate_certs.py --hostname mail.example.com
```

### 10.4 服务启动问题

#### 10.4.1 服务启动失败

**问题现象**：
```
Error: Failed to start SMTP tunnel server
```

**可能原因**：
1. 证书文件权限错误
2. 证书文件不存在
3. 端口被占用

**解决方案**：
```bash
# 1. 检查证书文件权限
ls -la cert/

# 2. 检查端口占用
sudo netstat -tlnp | grep 587
sudo lsof -i :587

# 3. 检查服务日志
sudo journalctl -u smtp-tunnel-server -n 50

# 4. 手动启动服务查看详细错误
python3 server.py --config config.yaml
```

#### 10.4.2 TLS 握手失败

**问题现象**：
```
Error: TLS handshake failed
```

**可能原因**：
1. 证书配置错误
2. TLS 版本不兼容
3. 加密套件不匹配

**解决方案**：
```bash
# 1. 测试 TLS 连接
openssl s_client -connect mail.example.com:587 -showcerts

# 2. 检查 TLS 配置
cat config.yaml | grep tls

# 3. 尝试使用不同的 TLS 版本
openssl s_client -connect mail.example.com:587 -tls1_2
openssl s_client -connect mail.example.com:587 -tls1_3

# 4. 检查服务器日志
sudo journalctl -u smtp-tunnel-server -n 50
```

---

## 11. 故障排除指南

### 11.1 诊断流程

#### 11.1.1 问题分类

| 问题类型 | 常见原因 | 诊断方法 |
|----------|----------|----------|
| **证书生成失败** | 依赖缺失、权限不足 | 检查日志、验证环境 |
| **证书配置错误** | 路径错误、参数错误 | 检查配置文件 |
| **证书验证失败** | CA 缺失、证书过期 | 验证证书链 |
| **服务启动失败** | 权限错误、端口占用 | 检查服务日志 |
| **TLS 握手失败** | 配置错误、版本不兼容 | 测试 TLS 连接 |

#### 11.1.2 诊断步骤

```bash
# 1. 检查证书文件
ls -la cert/
openssl x509 -in cert/server.crt -noout -text

# 2. 验证证书链
openssl verify -CAfile cert/ca.crt cert/server.crt

# 3. 测试 TLS 连接
openssl s_client -connect mail.example.com:587 -showcerts

# 4. 检查服务状态
sudo systemctl status smtp-tunnel-server

# 5. 查看服务日志
sudo journalctl -u smtp-tunnel-server -n 100
```

### 11.2 常见错误代码

#### 11.2.1 OpenSSL 错误代码

| 错误代码 | 说明 | 解决方案 |
|----------|------|----------|
| `02001002` | 系统库错误 | 检查系统库 |
| `0906D06C` | 证书读取错误 | 检查证书文件 |
| `0B080074` | 证书验证错误 | 验证证书链 |
| `14090086` | SSL 证书验证失败 | 检查证书配置 |

#### 11.2.2 Python 错误代码

| 错误类型 | 说明 | 解决方案 |
|----------|------|----------|
| `FileNotFoundError` | 文件未找到 | 检查文件路径 |
| `PermissionError` | 权限不足 | 检查文件权限 |
| `ssl.SSLError` | SSL 错误 | 检查 SSL 配置 |
| `ValueError` | 参数错误 | 检查参数配置 |

### 11.3 日志分析

#### 11.3.1 服务日志

```bash
# 查看实时日志
sudo journalctl -u smtp-tunnel-server -f

# 查看最近 100 行日志
sudo journalctl -u smtp-tunnel-server -n 100

# 查看今天的日志
sudo journalctl -u smtp-tunnel-server --since today

# 查看错误日志
sudo journalctl -u smtp-tunnel-server -p err
```

#### 11.3.2 应用日志

```bash
# 查看应用日志
tail -f /var/log/smtp-tunnel/smtp-tunnel.log

# 查看错误日志
grep ERROR /var/log/smtp-tunnel/smtp-tunnel.log

# 查看证书相关日志
grep -i cert /var/log/smtp-tunnel/smtp-tunnel.log
```

### 11.4 性能问题

#### 11.4.1 TLS 握手慢

**问题现象**：
- TLS 握手时间超过 1 秒
- 客户端连接延迟高

**可能原因**：
1. 证书链过长
2. 服务器性能问题
3. 网络延迟高

**解决方案**：
```bash
# 1. 测试 TLS 握手时间
time openssl s_client -connect mail.example.com:587

# 2. 优化证书链
# 使用更短的证书链

# 3. 启用会话恢复
# 在配置文件中启用会话缓存

# 4. 优化服务器性能
# 增加服务器资源
```

#### 11.4.2 证书验证慢

**问题现象**：
- 证书验证时间过长
- 客户端连接超时

**可能原因**：
1. OCSP 查询慢
2. CRL 下载慢
3. DNS 解析慢

**解决方案**：
```bash
# 1. 禁用 OCSP 查询（自签名证书）
# 在客户端配置中禁用证书验证

# 2. 使用本地 CA 证书
# 将 CA 证书部署到客户端

# 3. 优化 DNS 解析
# 使用本地 DNS 缓存
```

---

## 12. 附录：工具与资源

### 12.1 常用工具

#### 12.1.1 OpenSSL

| 命令 | 说明 | 示例 |
|------|------|------|
| `openssl genrsa` | 生成 RSA 私钥 | `openssl genrsa -out key.pem 2048` |
| `openssl req` | 生成 CSR | `openssl req -new -key key.pem -out csr.pem` |
| `openssl x509` | 处理 X.509 证书 | `openssl x509 -in cert.pem -noout -text` |
| `openssl verify` | 验证证书 | `openssl verify -CAfile ca.pem cert.pem` |
| `openssl s_client` | 测试 SSL/TLS 连接 | `openssl s_client -connect host:port` |

#### 12.1.2 Python cryptography

```python
# 安装 cryptography 库
pip install cryptography

# 基本使用示例
from cryptography import x509
from cryptography.hazmat.backends import default_backend

# 加载证书
with open('cert/server.crt', 'rb') as f:
    cert = x509.load_pem_x509_certificate(f.read(), default_backend())

# 获取证书信息
print(f"Subject: {cert.subject}")
print(f"Issuer: {cert.issuer}")
print(f"Not Before: {cert.not_valid_before}")
print(f"Not After: {cert.not_valid_after}")
```

### 12.2 在线工具

| 工具 | URL | 用途 |
|------|-----|------|
| **SSL Labs SSL Test** | https://www.ssllabs.com/ssltest/ | SSL 配置评估 |
| **Mozilla SSL Config Generator** | https://ssl-config.mozilla.org/ | SSL 配置生成 |
| **SSL Decoder** | https://www.sslshopper.com/ssl-decoder.html | 证书解码 |
| **Certificate Checker** | https://www.digicert.com/help/ | 证书检查 |
| **CryptoReport** | https://cryptoreport.websecurity.symantec.com/ | 证书报告 |

### 12.3 参考文档

#### 12.3.1 官方文档

- [OpenSSL Documentation](https://www.openssl.org/docs/)
- [Python cryptography Documentation](https://cryptography.io/en/latest/)
- [RFC 5280 - Internet X.509 PKI Certificate and CRL Profile](https://tools.ietf.org/html/rfc5280)
- [RFC 6960 - X.509 Internet PKI Online Certificate Status Protocol (OCSP)](https://tools.ietf.org/html/rfc6960)

#### 12.3.2 安全标准

- [NIST Special Publication 800-57 Part 1 Rev. 5](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57r1.pdf)
- [CA/Browser Forum Baseline Requirements](https://cabforum.org/baseline-requirements-documents/)
- [OWASP TLS Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet)

### 12.4 术语表

| 术语 | 英文全称 | 中文解释 |
|------|----------|----------|
| **SSL** | Secure Sockets Layer | 安全套接字层 |
| **TLS** | Transport Layer Security | 传输层安全协议 |
| **CA** | Certificate Authority | 证书颁发机构 |
| **CSR** | Certificate Signing Request | 证书签名请求 |
| **SAN** | Subject Alternative Name | 主题备用名称 |
| **OCSP** | Online Certificate Status Protocol | 在线证书状态协议 |
| **CRL** | Certificate Revocation List | 证书吊销列表 |
| **PKI** | Public Key Infrastructure | 公钥基础设施 |
| **RSA** | Rivest-Shamir-Adleman | RSA 加密算法 |
| **ECDSA** | Elliptic Curve Digital Signature Algorithm | 椭圆曲线数字签名算法 |
| **AES** | Advanced Encryption Standard | 高级加密标准 |
| **GCM** | Galois/Counter Mode | GCM 模式 |
| **SHA** | Secure Hash Algorithm | 安全哈希算法 |
| **PEM** | Privacy-Enhanced Mail | PEM 编码格式 |
| **DER** | Distinguished Encoding Rules | DER 编码格式 |
| **FQDN** | Fully Qualified Domain Name | 完全限定域名 |

---

**文档版本**: 1.0.0  
**最后更新**: 2026-01-18  
**维护者**: SMTP Tunnel Proxy Team
